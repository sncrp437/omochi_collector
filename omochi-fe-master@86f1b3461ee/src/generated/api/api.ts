/* tslint:disable */
/* eslint-disable */
/**
 * Omochi API
 * RESTful API for the Omochi System - A restaurant management and ordering platform
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@omochi.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * * `REGISTRATION` - Registration * `STOCKED_VENUE` - Stocked Venue * `ORDER` - Order * `CLICK` - Click
 * @export
 * @enum {string}
 */

export const ActionTypeEnum = {
    Registration: 'REGISTRATION',
    StockedVenue: 'STOCKED_VENUE',
    Order: 'ORDER',
    Click: 'CLICK'
} as const;

export type ActionTypeEnum = typeof ActionTypeEnum[keyof typeof ActionTypeEnum];


/**
 * Serializer for address data
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'prefecture': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'detail': string;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    'is_default'?: boolean;
}
/**
 * Serializer for creating address during registration
 * @export
 * @interface AddressRegistrationRequest
 */
export interface AddressRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressRegistrationRequest
     */
    'prefecture': string;
    /**
     * 
     * @type {string}
     * @memberof AddressRegistrationRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof AddressRegistrationRequest
     */
    'detail': string;
}
/**
 * Serializer for address data
 * @export
 * @interface AddressRequest
 */
export interface AddressRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'prefecture': string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'detail': string;
    /**
     * 
     * @type {boolean}
     * @memberof AddressRequest
     */
    'is_default'?: boolean;
}
/**
 * Serializer for application fee information
 * @export
 * @interface ApplicationFee
 */
export interface ApplicationFee {
    /**
     * Application fee amount in JPY
     * @type {number}
     * @memberof ApplicationFee
     */
    'amount': number;
    /**
     * Tax rate as a decimal
     * @type {number}
     * @memberof ApplicationFee
     */
    'tax_rate': number;
}
/**
 * Serializer for Article detail view
 * @export
 * @interface ArticleDetail
 */
export interface ArticleDetail {
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'description': string;
    /**
     * Article summary or excerpt
     * @type {string}
     * @memberof ArticleDetail
     */
    'summary'?: string | null;
    /**
     * Main article content
     * @type {string}
     * @memberof ArticleDetail
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'seo_image_url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'content_image_url': string;
    /**
     * 
     * @type {Array<VenueAffiliate>}
     * @memberof ArticleDetail
     */
    'venue_affiliates': Array<VenueAffiliate>;
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleDetail
     */
    'updated_at': string;
}
/**
 * Serializer for Article list view
 * @export
 * @interface ArticleList
 */
export interface ArticleList {
    /**
     * 
     * @type {string}
     * @memberof ArticleList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleList
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleList
     */
    'description': string;
    /**
     * Article summary or excerpt
     * @type {string}
     * @memberof ArticleList
     */
    'summary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ArticleList
     */
    'seo_image_url': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleList
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleList
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BlankEnum = {
    Empty: ''
} as const;

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


/**
 * Serializer for bulk order pickup confirmation
 * @export
 * @interface BulkOrderConfirmPickupRequest
 */
export interface BulkOrderConfirmPickupRequest {
    /**
     * List of order IDs to confirm pickup
     * @type {Array<string>}
     * @memberof BulkOrderConfirmPickupRequest
     */
    'order_ids': Array<string>;
}
/**
 * Serializer for bulk order status update
 * @export
 * @interface BulkOrderStatusRequest
 */
export interface BulkOrderStatusRequest {
    /**
     * List of order IDs to update
     * @type {Array<string>}
     * @memberof BulkOrderStatusRequest
     */
    'order_ids': Array<string>;
    /**
     * 
     * @type {Status514Enum}
     * @memberof BulkOrderStatusRequest
     */
    'status': Status514Enum;
}


/**
 * Serializer for bulk reservation status update
 * @export
 * @interface BulkReservationStatusRequest
 */
export interface BulkReservationStatusRequest {
    /**
     * List of reservation IDs to update
     * @type {Array<string>}
     * @memberof BulkReservationStatusRequest
     */
    'reservation_ids': Array<string>;
    /**
     * 
     * @type {Status514Enum}
     * @memberof BulkReservationStatusRequest
     */
    'status': Status514Enum;
}


/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'id': string;
    /**
     * 
     * @type {CampaignTypeEnum}
     * @memberof Campaign
     */
    'type'?: CampaignTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Campaign
     */
    'image_urls': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'cta_link'?: string | null;
    /**
     * 
     * @type {CampaignTargetVenue}
     * @memberof Campaign
     */
    'target_venue': CampaignTargetVenue;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface CampaignTargetVenue
 */
export interface CampaignTargetVenue {
    /**
     * Venue ID
     * @type {string}
     * @memberof CampaignTargetVenue
     */
    'id': string;
    /**
     * Venue name
     * @type {string}
     * @memberof CampaignTargetVenue
     */
    'name': string;
}
/**
 * * `venue_notice` - Venue Notice * `global` - Global
 * @export
 * @enum {string}
 */

export const CampaignTypeEnum = {
    VenueNotice: 'venue_notice',
    Global: 'global'
} as const;

export type CampaignTypeEnum = typeof CampaignTypeEnum[keyof typeof CampaignTypeEnum];


/**
 * 
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'user': string;
    /**
     * 
     * @type {MenuItem}
     * @memberof Cart
     */
    'menu_item_details': MenuItem;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CartRequest
 */
export interface CartRequest {
    /**
     * 
     * @type {string}
     * @memberof CartRequest
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof CartRequest
     */
    'menu_item': string;
    /**
     * 
     * @type {number}
     * @memberof CartRequest
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface ChangePassword200Response
 */
export interface ChangePassword200Response {
    /**
     * Success message
     * @type {string}
     * @memberof ChangePassword200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'venue'?: string | null;
    /**
     * 
     * @type {CouponTypeEnum}
     * @memberof Coupon
     */
    'type'?: CouponTypeEnum;
    /**
     * 
     * @type {ValueTypeEnum}
     * @memberof Coupon
     */
    'value_type'?: ValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'amount': string;
    /**
     * 
     * @type {PaidByEnum}
     * @memberof Coupon
     */
    'paid_by'?: PaidByEnum;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Coupon
     */
    'is_active'?: boolean;
    /**
     * Add order types (TAKEOUT, DINE_IN) separate by commas.
     * @type {Array<OrderTypeEnum>}
     * @memberof Coupon
     */
    'order_type'?: Array<OrderTypeEnum> | null;
    /**
     * Add payment methods (CASH, ONLINE) separate by commas.
     * @type {Array<PaymentMethodEnum>}
     * @memberof Coupon
     */
    'payment_method'?: Array<PaymentMethodEnum> | null;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'expiry_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Coupon
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface CouponRequest
 */
export interface CouponRequest {
    /**
     * 
     * @type {string}
     * @memberof CouponRequest
     */
    'venue'?: string | null;
    /**
     * 
     * @type {CouponTypeEnum}
     * @memberof CouponRequest
     */
    'type'?: CouponTypeEnum;
    /**
     * 
     * @type {ValueTypeEnum}
     * @memberof CouponRequest
     */
    'value_type'?: ValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CouponRequest
     */
    'amount': string;
    /**
     * 
     * @type {PaidByEnum}
     * @memberof CouponRequest
     */
    'paid_by'?: PaidByEnum;
    /**
     * 
     * @type {string}
     * @memberof CouponRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CouponRequest
     */
    'is_active'?: boolean;
    /**
     * Add order types (TAKEOUT, DINE_IN) separate by commas.
     * @type {Array<OrderTypeEnum>}
     * @memberof CouponRequest
     */
    'order_type'?: Array<OrderTypeEnum> | null;
    /**
     * Add payment methods (CASH, ONLINE) separate by commas.
     * @type {Array<PaymentMethodEnum>}
     * @memberof CouponRequest
     */
    'payment_method'?: Array<PaymentMethodEnum> | null;
    /**
     * 
     * @type {string}
     * @memberof CouponRequest
     */
    'expiry_date'?: string | null;
}


/**
 * * `SERVICE_FEE` - Service Fee * `VENUE` - Issued by Venue * `CAMPAIGN` - Campaign by Omochi
 * @export
 * @enum {string}
 */

export const CouponTypeEnum = {
    ServiceFee: 'SERVICE_FEE',
    Venue: 'VENUE',
    Campaign: 'CAMPAIGN'
} as const;

export type CouponTypeEnum = typeof CouponTypeEnum[keyof typeof CouponTypeEnum];


/**
 * Custom token serializer that includes user details
 * @export
 * @interface CustomTokenObtainPairRequest
 */
export interface CustomTokenObtainPairRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomTokenObtainPairRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CustomTokenObtainPairRequest
     */
    'password': string;
}
/**
 * * `WEB` - Web Browser * `ANDROID` - Android * `IOS` - iOS
 * @export
 * @enum {string}
 */

export const DeviceTypeEnum = {
    Web: 'WEB',
    Android: 'ANDROID',
    Ios: 'IOS'
} as const;

export type DeviceTypeEnum = typeof DeviceTypeEnum[keyof typeof DeviceTypeEnum];


/**
 * Serializer for FCM tokens
 * @export
 * @interface FCMToken
 */
export interface FCMToken {
    /**
     * 
     * @type {string}
     * @memberof FCMToken
     */
    'id': string;
    /**
     * Firebase Cloud Messaging token
     * @type {string}
     * @memberof FCMToken
     */
    'token': string;
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof FCMToken
     */
    'device_type'?: DeviceTypeEnum;
    /**
     * Unique device identifier
     * @type {string}
     * @memberof FCMToken
     */
    'device_id'?: string | null;
    /**
     * Whether this token is active and valid
     * @type {boolean}
     * @memberof FCMToken
     */
    'is_active': boolean;
    /**
     * 
     * @type {string}
     * @memberof FCMToken
     */
    'created_at': string;
    /**
     * Last time this token was used for notifications
     * @type {string}
     * @memberof FCMToken
     */
    'last_used': string;
}


/**
 * Serializer for registering FCM tokens
 * @export
 * @interface FCMTokenRegistrationRequest
 */
export interface FCMTokenRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof FCMTokenRegistrationRequest
     */
    'token': string;
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof FCMTokenRegistrationRequest
     */
    'device_type'?: DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FCMTokenRegistrationRequest
     */
    'device_id'?: string;
}


/**
 * Serializer for FCM tokens
 * @export
 * @interface FCMTokenRequest
 */
export interface FCMTokenRequest {
    /**
     * Firebase Cloud Messaging token
     * @type {string}
     * @memberof FCMTokenRequest
     */
    'token': string;
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof FCMTokenRequest
     */
    'device_type'?: DeviceTypeEnum;
    /**
     * Unique device identifier
     * @type {string}
     * @memberof FCMTokenRequest
     */
    'device_id'?: string | null;
}


/**
 * * `ja` - Japanese * `en` - English
 * @export
 * @enum {string}
 */

export const LangEnum = {
    Ja: 'ja',
    En: 'en'
} as const;

export type LangEnum = typeof LangEnum[keyof typeof LangEnum];


/**
 * Serializer for the login response that includes tokens and user data
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * JWT access token for API authorization
     * @type {string}
     * @memberof LoginResponse
     */
    'access': string;
    /**
     * JWT refresh token to obtain new access tokens
     * @type {string}
     * @memberof LoginResponse
     */
    'refresh': string;
    /**
     * 
     * @type {User}
     * @memberof LoginResponse
     */
    'user': User;
}
/**
 * Serializer for menu category
 * @export
 * @interface MenuCategory
 */
export interface MenuCategory {
    /**
     * 
     * @type {string}
     * @memberof MenuCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MenuCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuCategory
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MenuCategory
     */
    'display_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MenuCategory
     */
    'system_category': boolean;
}
/**
 * Serializer for menu category
 * @export
 * @interface MenuCategoryRequest
 */
export interface MenuCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof MenuCategoryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuCategoryRequest
     */
    'name_en'?: string;
    /**
     * 
     * @type {string}
     * @memberof MenuCategoryRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MenuCategoryRequest
     */
    'display_order'?: number;
}
/**
 * Serializer for menu category with its items
 * @export
 * @interface MenuCategoryWithItems
 */
export interface MenuCategoryWithItems {
    /**
     * 
     * @type {string}
     * @memberof MenuCategoryWithItems
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MenuCategoryWithItems
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuCategoryWithItems
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MenuCategoryWithItems
     */
    'display_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MenuCategoryWithItems
     */
    'system_category': boolean;
    /**
     * 
     * @type {Array<MenuItem>}
     * @memberof MenuCategoryWithItems
     */
    'items': Array<MenuItem>;
}
/**
 * Serializer for menu item
 * @export
 * @interface MenuItem
 */
export interface MenuItem {
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'take_out_price'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuItem
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'category_name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'ingredients'?: string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof MenuItem
     */
    'preparation_time'?: number | null;
    /**
     * Is this menu item out of stock?
     * @type {boolean}
     * @memberof MenuItem
     */
    'is_out_of_stock': boolean;
    /**
     * Does this menu item contain alcohol?
     * @type {boolean}
     * @memberof MenuItem
     */
    'is_alcoholic'?: boolean;
    /**
     * Is this menu item a priority pass?
     * @type {boolean}
     * @memberof MenuItem
     */
    'is_priority_pass'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuItem
     */
    'origin_id': string;
}
/**
 * Serializer for detailed menu item information
 * @export
 * @interface MenuItemDetail
 */
export interface MenuItemDetail {
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'image'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'take_out_price'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuItemDetail
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'category_name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemDetail
     */
    'ingredients'?: string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof MenuItemDetail
     */
    'preparation_time'?: number | null;
    /**
     * Is this menu item out of stock?
     * @type {boolean}
     * @memberof MenuItemDetail
     */
    'is_out_of_stock': boolean;
    /**
     * Does this menu item contain alcohol?
     * @type {boolean}
     * @memberof MenuItemDetail
     */
    'is_alcoholic'?: boolean;
    /**
     * Is this menu item a priority pass?
     * @type {boolean}
     * @memberof MenuItemDetail
     */
    'is_priority_pass'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MenuItemDetail
     */
    'origin_id': number;
}
/**
 * Serializer for menu item
 * @export
 * @interface MenuItemRequest
 */
export interface MenuItemRequest {
    /**
     * 
     * @type {string}
     * @memberof MenuItemRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemRequest
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {File}
     * @memberof MenuItemRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItemRequest
     */
    'take_out_price'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuItemRequest
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuItemRequest
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuItemRequest
     */
    'ingredients'?: string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof MenuItemRequest
     */
    'preparation_time'?: number | null;
    /**
     * Does this menu item contain alcohol?
     * @type {boolean}
     * @memberof MenuItemRequest
     */
    'is_alcoholic'?: boolean;
    /**
     * Is this menu item a priority pass?
     * @type {boolean}
     * @memberof MenuItemRequest
     */
    'is_priority_pass'?: boolean;
}
/**
 * 
 * @export
 * @interface MenuItemStockUpdate
 */
export interface MenuItemStockUpdate {
    /**
     * List of MenuItem UUIDs to update
     * @type {Array<string>}
     * @memberof MenuItemStockUpdate
     */
    'menu_item_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface MenuItemStockUpdateRequest
 */
export interface MenuItemStockUpdateRequest {
    /**
     * List of MenuItem UUIDs to update
     * @type {Array<string>}
     * @memberof MenuItemStockUpdateRequest
     */
    'menu_item_ids': Array<string>;
}
/**
 * * `PENDING` - Pending * `CONFIRMED` - Confirmed * `PREPARING` - Preparing * `READY` - Ready * `COMPLETED` - Completed * `CANCELLED` - Cancelled
 * @export
 * @enum {string}
 */

export const NewStatusEnum = {
    Pending: 'PENDING',
    Confirmed: 'CONFIRMED',
    Preparing: 'PREPARING',
    Ready: 'READY',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type NewStatusEnum = typeof NewStatusEnum[keyof typeof NewStatusEnum];


/**
 * Serializer for notifications
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'message': string;
    /**
     * 
     * @type {NotificationTypeEnum}
     * @memberof Notification
     */
    'type': NotificationTypeEnum;
    /**
     * 
     * @type {Status5d6Enum}
     * @memberof Notification
     */
    'status'?: Status5d6Enum;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'reference_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'reference_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'click_action'?: string | null;
}


/**
 * Serializer for updating notification read status
 * @export
 * @interface NotificationReadStatus
 */
export interface NotificationReadStatus {
    /**
     * 
     * @type {Status5d6Enum}
     * @memberof NotificationReadStatus
     */
    'status'?: Status5d6Enum;
}


/**
 * Serializer for updating notification read status
 * @export
 * @interface NotificationReadStatusRequest
 */
export interface NotificationReadStatusRequest {
    /**
     * 
     * @type {Status5d6Enum}
     * @memberof NotificationReadStatusRequest
     */
    'status'?: Status5d6Enum;
}


/**
 * * `ORDER_STATUS` - Order Status * `RESERVATION` - Reservation * `SYSTEM` - System * `TIME_SLOT_AVAILABLE` - Time Slot Available
 * @export
 * @enum {string}
 */

export const NotificationTypeEnum = {
    OrderStatus: 'ORDER_STATUS',
    Reservation: 'RESERVATION',
    System: 'SYSTEM',
    TimeSlotAvailable: 'TIME_SLOT_AVAILABLE'
} as const;

export type NotificationTypeEnum = typeof NotificationTypeEnum[keyof typeof NotificationTypeEnum];


/**
 * 
 * @export
 * @interface NotificationsUpcomingReservationsRetrieve200Response
 */
export interface NotificationsUpcomingReservationsRetrieve200Response {
    /**
     * Number of upcoming reservations in the next 30 minutes
     * @type {number}
     * @memberof NotificationsUpcomingReservationsRetrieve200Response
     */
    'reservation_count'?: number;
    /**
     * Number of upcoming orders in the next 30 minutes
     * @type {number}
     * @memberof NotificationsUpcomingReservationsRetrieve200Response
     */
    'order_count'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NullEnum = {
    Null: 'null'
} as const;

export type NullEnum = typeof NullEnum[keyof typeof NullEnum];


/**
 * Serializer for order detail views
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'order_code': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'user_first_name': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'user_last_name': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'user_phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'venue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'venue_name': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'venue_logo': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'venue_website': string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'time_slot'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'user_coupon': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'total_coupon_amount': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'takeout_fee_subsidized_amount'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'application_fee_amount'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'application_fee_discount_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'order_discount_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'end_time': string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'party_size': number;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof Order
     */
    'status'?: NewStatusEnum;
    /**
     * 
     * @type {OrderTypeEnum}
     * @memberof Order
     */
    'order_type': OrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'order_date': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'total_amount': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'total': string;
    /**
     * 
     * @type {PaymentStatusEnum}
     * @memberof Order
     */
    'payment_status'?: PaymentStatusEnum;
    /**
     * 
     * @type {OrderPaymentMethod}
     * @memberof Order
     */
    'payment_method'?: OrderPaymentMethod | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'pickup_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'reservation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    'items': Array<OrderItem>;
    /**
     * 
     * @type {Array<OrderQuestion>}
     * @memberof Order
     */
    'order_questions': Array<OrderQuestion>;
    /**
     * 
     * @type {Array<OrderStatusHistory>}
     * @memberof Order
     */
    'status_history': Array<OrderStatusHistory>;
}


/**
 * Serializer for creating orders with items
 * @export
 * @interface OrderCreateRequest
 */
export interface OrderCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'venue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'time_slot': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'user_coupon'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderCreateRequest
     */
    'party_size': number;
    /**
     * 
     * @type {OrderTypeEnum}
     * @memberof OrderCreateRequest
     */
    'order_type': OrderTypeEnum;
    /**
     * 
     * @type {OrderPaymentMethod}
     * @memberof OrderCreateRequest
     */
    'payment_method'?: OrderPaymentMethod | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'pickup_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'reservation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<OrderItemRequest>}
     * @memberof OrderCreateRequest
     */
    'items': Array<OrderItemRequest>;
    /**
     * 
     * @type {Array<OrderQuestionInputRequest>}
     * @memberof OrderCreateRequest
     */
    'venue_questions'?: Array<OrderQuestionInputRequest>;
    /**
     * 
     * @type {LangEnum}
     * @memberof OrderCreateRequest
     */
    'lang'?: LangEnum;
}


/**
 * Serializer for order item
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'menu_item': string;
    /**
     * 
     * @type {MenuItem}
     * @memberof OrderItem
     */
    'menu_item_details': MenuItem;
    /**
     * 
     * @type {number}
     * @memberof OrderItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'subtotal': string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'special_request'?: string | null;
}
/**
 * Serializer for order item
 * @export
 * @interface OrderItemRequest
 */
export interface OrderItemRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderItemRequest
     */
    'menu_item': string;
    /**
     * 
     * @type {number}
     * @memberof OrderItemRequest
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItemRequest
     */
    'special_request'?: string | null;
}
/**
 * Serializer for order list views - optimized with fewer fields
 * @export
 * @interface OrderList
 */
export interface OrderList {
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'order_code': string;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'venue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'venue_name': string;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderList
     */
    'status'?: NewStatusEnum;
    /**
     * 
     * @type {OrderTypeEnum}
     * @memberof OrderList
     */
    'order_type': OrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'order_date': string;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'total_amount': string;
    /**
     * 
     * @type {PaymentStatusEnum}
     * @memberof OrderList
     */
    'payment_status'?: PaymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'total': string;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'pickup_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'reservation'?: string | null;
}


/**
 * @type OrderPaymentMethod
 * @export
 */
export type OrderPaymentMethod = BlankEnum | PaymentMethodEnum;

/**
 * Serializer for order questions and answers
 * @export
 * @interface OrderQuestion
 */
export interface OrderQuestion {
    /**
     * 
     * @type {string}
     * @memberof OrderQuestion
     */
    'id': string;
    /**
     * Question text at the time of order (Japanese)
     * @type {string}
     * @memberof OrderQuestion
     */
    'question': string;
    /**
     * Customer\'s answer to the question (max 50 characters)
     * @type {string}
     * @memberof OrderQuestion
     */
    'answer': string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuestion
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuestion
     */
    'updated_at': string;
}
/**
 * Serializer for accepting question answers during order creation
 * @export
 * @interface OrderQuestionInputRequest
 */
export interface OrderQuestionInputRequest {
    /**
     * ID of the venue question
     * @type {string}
     * @memberof OrderQuestionInputRequest
     */
    'question_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrderQuestionInputRequest
     */
    'answer'?: string;
}
/**
 * Serializer for order questions and answers
 * @export
 * @interface OrderQuestionRequest
 */
export interface OrderQuestionRequest {
    /**
     * Question text at the time of order (Japanese)
     * @type {string}
     * @memberof OrderQuestionRequest
     */
    'question': string;
    /**
     * Customer\'s answer to the question (max 50 characters)
     * @type {string}
     * @memberof OrderQuestionRequest
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface OrderStatusHistory
 */
export interface OrderStatusHistory {
    /**
     * 
     * @type {string}
     * @memberof OrderStatusHistory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrderStatusHistory
     */
    'order': string;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderStatusHistory
     */
    'old_status': NewStatusEnum;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderStatusHistory
     */
    'new_status': NewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderStatusHistory
     */
    'changed_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrderStatusHistory
     */
    'changed_by': string | null;
}


/**
 * 
 * @export
 * @interface OrderStatusHistoryRequest
 */
export interface OrderStatusHistoryRequest {
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderStatusHistoryRequest
     */
    'old_status': NewStatusEnum;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderStatusHistoryRequest
     */
    'new_status': NewStatusEnum;
}


/**
 * Serializer for updating order status
 * @export
 * @interface OrderStatusUpdate
 */
export interface OrderStatusUpdate {
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderStatusUpdate
     */
    'status'?: NewStatusEnum;
}


/**
 * Serializer for updating order status
 * @export
 * @interface OrderStatusUpdateRequest
 */
export interface OrderStatusUpdateRequest {
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof OrderStatusUpdateRequest
     */
    'status'?: NewStatusEnum;
}


/**
 * * `TAKEOUT` - Takeout * `DINE_IN` - Dine In
 * @export
 * @enum {string}
 */

export const OrderTypeEnum = {
    Takeout: 'TAKEOUT',
    DineIn: 'DINE_IN'
} as const;

export type OrderTypeEnum = typeof OrderTypeEnum[keyof typeof OrderTypeEnum];


/**
 * 
 * @export
 * @interface OrdersPayCreate200Response
 */
export interface OrdersPayCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof OrdersPayCreate200Response
     */
    'payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrdersPayCreate200Response
     */
    'checkout_session_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrdersPayCreate200Response
     */
    'checkout_url'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedArticleListList
 */
export interface PaginatedArticleListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedArticleListList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArticleListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedArticleListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ArticleList>}
     * @memberof PaginatedArticleListList
     */
    'results': Array<ArticleList>;
}
/**
 * 
 * @export
 * @interface PaginatedCouponList
 */
export interface PaginatedCouponList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCouponList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCouponList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCouponList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Coupon>}
     * @memberof PaginatedCouponList
     */
    'results': Array<Coupon>;
}
/**
 * 
 * @export
 * @interface PaginatedNotificationList
 */
export interface PaginatedNotificationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNotificationList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof PaginatedNotificationList
     */
    'results': Array<Notification>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderListList
 */
export interface PaginatedOrderListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderListList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderList>}
     * @memberof PaginatedOrderListList
     */
    'results': Array<OrderList>;
}
/**
 * 
 * @export
 * @interface PaginatedReservationList
 */
export interface PaginatedReservationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedReservationList
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedReservationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedReservationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Reservation>}
     * @memberof PaginatedReservationList
     */
    'results': Array<Reservation>;
}
/**
 * * `OMOCCHI` - Omochi * `VENUE` - Venue
 * @export
 * @enum {string}
 */

export const PaidByEnum = {
    Omocchi: 'OMOCCHI',
    Venue: 'VENUE'
} as const;

export type PaidByEnum = typeof PaidByEnum[keyof typeof PaidByEnum];


/**
 * Serializer for PartnerStore model
 * @export
 * @interface PartnerStore
 */
export interface PartnerStore {
    /**
     * 
     * @type {string}
     * @memberof PartnerStore
     */
    'id': string;
    /**
     * Partner store name
     * @type {string}
     * @memberof PartnerStore
     */
    'name'?: string | null;
    /**
     * Partner store image (PNG/JPG only)
     * @type {string}
     * @memberof PartnerStore
     */
    'image': string;
    /**
     * Order for display (lower numbers shown first)
     * @type {number}
     * @memberof PartnerStore
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartnerStore
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerStore
     */
    'updated_at': string;
}
/**
 * Serializer for changing user password
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * User\'s current password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'current_password': string;
    /**
     * New password (6-12 characters)
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'new_password': string;
}
/**
 * Serializer for confirming a password reset
 * @export
 * @interface PasswordResetConfirmRequest
 */
export interface PasswordResetConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'new_password': string;
}
/**
 * Serializer for requesting a password reset
 * @export
 * @interface PasswordResetRequest
 */
export interface PasswordResetRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'email': string;
}
/**
 * Serializer for requesting a password reset
 * @export
 * @interface PasswordResetRequestRequest
 */
export interface PasswordResetRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetRequestRequest
     */
    'email': string;
}
/**
 * Serializer for address data
 * @export
 * @interface PatchedAddressRequest
 */
export interface PatchedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedAddressRequest
     */
    'prefecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAddressRequest
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAddressRequest
     */
    'detail'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAddressRequest
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedCartRequest
 */
export interface PatchedCartRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCartRequest
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCartRequest
     */
    'menu_item'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCartRequest
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface PatchedCouponRequest
 */
export interface PatchedCouponRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCouponRequest
     */
    'venue'?: string | null;
    /**
     * 
     * @type {CouponTypeEnum}
     * @memberof PatchedCouponRequest
     */
    'type'?: CouponTypeEnum;
    /**
     * 
     * @type {ValueTypeEnum}
     * @memberof PatchedCouponRequest
     */
    'value_type'?: ValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedCouponRequest
     */
    'amount'?: string;
    /**
     * 
     * @type {PaidByEnum}
     * @memberof PatchedCouponRequest
     */
    'paid_by'?: PaidByEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedCouponRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedCouponRequest
     */
    'is_active'?: boolean;
    /**
     * Add order types (TAKEOUT, DINE_IN) separate by commas.
     * @type {Array<OrderTypeEnum>}
     * @memberof PatchedCouponRequest
     */
    'order_type'?: Array<OrderTypeEnum> | null;
    /**
     * Add payment methods (CASH, ONLINE) separate by commas.
     * @type {Array<PaymentMethodEnum>}
     * @memberof PatchedCouponRequest
     */
    'payment_method'?: Array<PaymentMethodEnum> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCouponRequest
     */
    'expiry_date'?: string | null;
}


/**
 * Serializer for menu category
 * @export
 * @interface PatchedMenuCategoryRequest
 */
export interface PatchedMenuCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuCategoryRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuCategoryRequest
     */
    'name_en'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuCategoryRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMenuCategoryRequest
     */
    'display_order'?: number;
}
/**
 * Serializer for menu item
 * @export
 * @interface PatchedMenuItemRequest
 */
export interface PatchedMenuItemRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuItemRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuItemRequest
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuItemRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {File}
     * @memberof PatchedMenuItemRequest
     */
    'image'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuItemRequest
     */
    'take_out_price'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMenuItemRequest
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuItemRequest
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedMenuItemRequest
     */
    'ingredients'?: string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof PatchedMenuItemRequest
     */
    'preparation_time'?: number | null;
    /**
     * Does this menu item contain alcohol?
     * @type {boolean}
     * @memberof PatchedMenuItemRequest
     */
    'is_alcoholic'?: boolean;
    /**
     * Is this menu item a priority pass?
     * @type {boolean}
     * @memberof PatchedMenuItemRequest
     */
    'is_priority_pass'?: boolean;
}
/**
 * Serializer for order detail views
 * @export
 * @interface PatchedOrderRequest
 */
export interface PatchedOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'venue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'time_slot'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'takeout_fee_subsidized_amount'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'application_fee_amount'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'application_fee_discount_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'order_discount_amount'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOrderRequest
     */
    'party_size'?: number;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof PatchedOrderRequest
     */
    'status'?: NewStatusEnum;
    /**
     * 
     * @type {OrderTypeEnum}
     * @memberof PatchedOrderRequest
     */
    'order_type'?: OrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'total'?: string;
    /**
     * 
     * @type {PaymentStatusEnum}
     * @memberof PatchedOrderRequest
     */
    'payment_status'?: PaymentStatusEnum;
    /**
     * 
     * @type {OrderPaymentMethod}
     * @memberof PatchedOrderRequest
     */
    'payment_method'?: OrderPaymentMethod | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'pickup_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'reservation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderRequest
     */
    'note'?: string | null;
}


/**
 * Serializer for reservation
 * @export
 * @interface PatchedReservationRequest
 */
export interface PatchedReservationRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedReservationRequest
     */
    'venue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedReservationRequest
     */
    'time_slot'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedReservationRequest
     */
    'date'?: string;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof PatchedReservationRequest
     */
    'status'?: NewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedReservationRequest
     */
    'party_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedReservationRequest
     */
    'table_preference'?: string | null;
    /**
     * 
     * @type {Array<ReservationQuestionInputRequest>}
     * @memberof PatchedReservationRequest
     */
    'venue_questions'?: Array<ReservationQuestionInputRequest>;
    /**
     * 
     * @type {LangEnum}
     * @memberof PatchedReservationRequest
     */
    'lang'?: LangEnum;
}


/**
 * Serializer for StockedVenue model
 * @export
 * @interface PatchedStockedVenueRequest
 */
export interface PatchedStockedVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedStockedVenueRequest
     */
    'venue'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStockedVenueRequest
     */
    'is_favorite'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedTimeSlotRequest
 */
export interface PatchedTimeSlotRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedTimeSlotRequest
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTimeSlotRequest
     */
    'end_time'?: string;
    /**
     * Interval in minutes
     * @type {number}
     * @memberof PatchedTimeSlotRequest
     */
    'slot_interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedTimeSlotRequest
     */
    'max_reservations'?: number;
    /**
     * Number of priority pass slots
     * @type {number}
     * @memberof PatchedTimeSlotRequest
     */
    'priority_pass_slot'?: number;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof PatchedTimeSlotRequest
     */
    'service_type'?: ServiceTypeEnum;
    /**
     * Time frame pause status
     * @type {boolean}
     * @memberof PatchedTimeSlotRequest
     */
    'is_paused'?: boolean;
}


/**
 * 
 * @export
 * @interface PatchedUserCouponRequest
 */
export interface PatchedUserCouponRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'user'?: string;
    /**
     * ID of the coupon to assign
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'coupon_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'order'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserCouponRequest
     */
    'is_used'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'used_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'created_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'expiry_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserCouponRequest
     */
    'note'?: string | null;
}
/**
 * Serializer for updating user profile with limited fields
 * @export
 * @interface PatchedUserProfileUpdateRequest
 */
export interface PatchedUserProfileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdateRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdateRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {File}
     * @memberof PatchedUserProfileUpdateRequest
     */
    'avatar'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdateRequest
     */
    'phone_number'?: string | null;
}
/**
 * Serializer for Venue model
 * @export
 * @interface PatchedVenueRequest
 */
export interface PatchedVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'announcement'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'website'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'opening_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'enable_reservation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'enable_eat_in'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'enable_take_out'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'enable_order_questions'?: boolean;
    /**
     * 
     * @type {File}
     * @memberof PatchedVenueRequest
     */
    'logo'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'qr_code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'enable_cash_payment'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVenueRequest
     */
    'enable_online_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'additional_info'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'additional_info_en'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'genre'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'genre_en'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedVenueRequest
     */
    'buffer_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'nearest_station'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVenueRequest
     */
    'nearest_station_en'?: string;
    /**
     * Absolute application fee amount in JPY for takeout orders
     * @type {number}
     * @memberof PatchedVenueRequest
     */
    'custom_platform_fee_amount'?: number | null;
}
/**
 * 
 * @export
 * @interface PausedTimeSlot
 */
export interface PausedTimeSlot {
    /**
     * 
     * @type {Array<string>}
     * @memberof PausedTimeSlot
     */
    'time_slot_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface PausedTimeSlotRequest
 */
export interface PausedTimeSlotRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PausedTimeSlotRequest
     */
    'time_slot_ids': Array<string>;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof PausedTimeSlotRequest
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PausedTimeSlotRequest
     */
    'is_paused': boolean;
}


/**
 * 
 * @export
 * @interface PaymentCheckoutSessionRequest
 */
export interface PaymentCheckoutSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentCheckoutSessionRequest
     */
    'order_id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCheckoutSessionRequest
     */
    'return_url'?: string;
}
/**
 * * `CASH` - Cash * `ONLINE` - Online
 * @export
 * @enum {string}
 */

export const PaymentMethodEnum = {
    Cash: 'CASH',
    Online: 'ONLINE'
} as const;

export type PaymentMethodEnum = typeof PaymentMethodEnum[keyof typeof PaymentMethodEnum];


/**
 * * `PENDING` - Pending * `PAID` - Paid * `FAILED` - Failed
 * @export
 * @enum {string}
 */

export const PaymentStatusEnum = {
    Pending: 'PENDING',
    Paid: 'PAID',
    Failed: 'FAILED'
} as const;

export type PaymentStatusEnum = typeof PaymentStatusEnum[keyof typeof PaymentStatusEnum];


/**
 * 
 * @export
 * @interface PaymentTransaction
 */
export interface PaymentTransaction {
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'order': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'amount': string;
    /**
     * 
     * @type {PaymentTransactionStatusEnum}
     * @memberof PaymentTransaction
     */
    'status': PaymentTransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'updated_at': string;
}


/**
 * * `PENDING` - Pending * `PROCESSING` - Processing * `COMPLETED` - Completed * `FAILED` - Failed * `REFUNDED` - Refunded * `CANCELLED` - Cancelled
 * @export
 * @enum {string}
 */

export const PaymentTransactionStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Cancelled: 'CANCELLED'
} as const;

export type PaymentTransactionStatusEnum = typeof PaymentTransactionStatusEnum[keyof typeof PaymentTransactionStatusEnum];


/**
 * 
 * @export
 * @interface PaymentsCheckStatusRetrieve200Response
 */
export interface PaymentsCheckStatusRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof PaymentsCheckStatusRetrieve200Response
     */
    'status'?: PaymentsCheckStatusRetrieve200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentsCheckStatusRetrieve200Response
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsCheckStatusRetrieve200Response
     */
    'venue_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentsCheckStatusRetrieve200Response
     */
    'amount'?: number;
}

export const PaymentsCheckStatusRetrieve200ResponseStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type PaymentsCheckStatusRetrieve200ResponseStatusEnum = typeof PaymentsCheckStatusRetrieve200ResponseStatusEnum[keyof typeof PaymentsCheckStatusRetrieve200ResponseStatusEnum];

/**
 * * `ja` - Japanese * `en` - English
 * @export
 * @enum {string}
 */

export const PreferredLanguageEnum = {
    Ja: 'ja',
    En: 'en'
} as const;

export type PreferredLanguageEnum = typeof PreferredLanguageEnum[keyof typeof PreferredLanguageEnum];


/**
 * Serializer for logging referral clicks
 * @export
 * @interface RefLogClickRequest
 */
export interface RefLogClickRequest {
    /**
     * The referral code
     * @type {string}
     * @memberof RefLogClickRequest
     */
    'ref_code': string;
    /**
     * The venue ID being referenced
     * @type {string}
     * @memberof RefLogClickRequest
     */
    'venue_id': string;
}
/**
 * Serializer for RefLog response
 * @export
 * @interface RefLogResponse
 */
export interface RefLogResponse {
    /**
     * 
     * @type {string}
     * @memberof RefLogResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RefLogResponse
     */
    'user': string | null;
    /**
     * The ID of the referrer user or referral code
     * @type {string}
     * @memberof RefLogResponse
     */
    'ref_id': string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof RefLogResponse
     */
    'action_type': ActionTypeEnum;
    /**
     * ID of the related action (order ID, registration ID, etc.)
     * @type {string}
     * @memberof RefLogResponse
     */
    'action_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefLogResponse
     */
    'venue': string | null;
    /**
     * 
     * @type {string}
     * @memberof RefLogResponse
     */
    'created_at': string;
}


/**
 * Serializer for reservation
 * @export
 * @interface Reservation
 */
export interface Reservation {
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'venue': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'venue_name': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'venue_logo': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'venue_website': string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'user_first_name': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'user_last_name': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'user_phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'time_slot': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'end_time': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'date': string;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof Reservation
     */
    'status'?: NewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Reservation
     */
    'party_size': number;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'reservation_code': string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'table_preference'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<ReservationStatusHistory>}
     * @memberof Reservation
     */
    'status_history': Array<ReservationStatusHistory>;
    /**
     * 
     * @type {Array<ReservationQuestion>}
     * @memberof Reservation
     */
    'reservation_questions': Array<ReservationQuestion>;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    'order_id': string;
    /**
     * 
     * @type {LangEnum}
     * @memberof Reservation
     */
    'lang'?: LangEnum;
}


/**
 * Serializer for reservation questions and answers
 * @export
 * @interface ReservationQuestion
 */
export interface ReservationQuestion {
    /**
     * 
     * @type {string}
     * @memberof ReservationQuestion
     */
    'id': string;
    /**
     * Question text at the time of reservation (Japanese)
     * @type {string}
     * @memberof ReservationQuestion
     */
    'question': string;
    /**
     * Customer\'s answer to the question (max 50 characters)
     * @type {string}
     * @memberof ReservationQuestion
     */
    'answer': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationQuestion
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationQuestion
     */
    'updated_at': string;
}
/**
 * Serializer for accepting question answers during reservation creation
 * @export
 * @interface ReservationQuestionInput
 */
export interface ReservationQuestionInput {
    /**
     * ID of the venue question
     * @type {string}
     * @memberof ReservationQuestionInput
     */
    'question_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationQuestionInput
     */
    'answer'?: string;
}
/**
 * Serializer for accepting question answers during reservation creation
 * @export
 * @interface ReservationQuestionInputRequest
 */
export interface ReservationQuestionInputRequest {
    /**
     * ID of the venue question
     * @type {string}
     * @memberof ReservationQuestionInputRequest
     */
    'question_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationQuestionInputRequest
     */
    'answer'?: string;
}
/**
 * Serializer for reservation questions and answers
 * @export
 * @interface ReservationQuestionRequest
 */
export interface ReservationQuestionRequest {
    /**
     * Question text at the time of reservation (Japanese)
     * @type {string}
     * @memberof ReservationQuestionRequest
     */
    'question': string;
    /**
     * Customer\'s answer to the question (max 50 characters)
     * @type {string}
     * @memberof ReservationQuestionRequest
     */
    'answer': string;
}
/**
 * Serializer for reservation
 * @export
 * @interface ReservationRequest
 */
export interface ReservationRequest {
    /**
     * 
     * @type {string}
     * @memberof ReservationRequest
     */
    'venue': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationRequest
     */
    'time_slot': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationRequest
     */
    'date': string;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationRequest
     */
    'status'?: NewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ReservationRequest
     */
    'party_size': number;
    /**
     * 
     * @type {string}
     * @memberof ReservationRequest
     */
    'table_preference'?: string | null;
    /**
     * 
     * @type {Array<ReservationQuestionInputRequest>}
     * @memberof ReservationRequest
     */
    'venue_questions'?: Array<ReservationQuestionInputRequest>;
    /**
     * 
     * @type {LangEnum}
     * @memberof ReservationRequest
     */
    'lang'?: LangEnum;
}


/**
 * 
 * @export
 * @interface ReservationStatusHistory
 */
export interface ReservationStatusHistory {
    /**
     * 
     * @type {string}
     * @memberof ReservationStatusHistory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationStatusHistory
     */
    'reservation': string;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationStatusHistory
     */
    'old_status': NewStatusEnum;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationStatusHistory
     */
    'new_status': NewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReservationStatusHistory
     */
    'changed_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReservationStatusHistory
     */
    'changed_by': string | null;
}


/**
 * 
 * @export
 * @interface ReservationStatusHistoryRequest
 */
export interface ReservationStatusHistoryRequest {
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationStatusHistoryRequest
     */
    'old_status': NewStatusEnum;
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationStatusHistoryRequest
     */
    'new_status': NewStatusEnum;
}


/**
 * Serializer for updating reservation status
 * @export
 * @interface ReservationStatusUpdate
 */
export interface ReservationStatusUpdate {
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationStatusUpdate
     */
    'status'?: NewStatusEnum;
}


/**
 * Serializer for updating reservation status
 * @export
 * @interface ReservationStatusUpdateRequest
 */
export interface ReservationStatusUpdateRequest {
    /**
     * 
     * @type {NewStatusEnum}
     * @memberof ReservationStatusUpdateRequest
     */
    'status'?: NewStatusEnum;
}


/**
 * * `TAKEOUT` - Takeout * `DINE_IN` - Dine In
 * @export
 * @enum {string}
 */

export const ServiceTypeEnum = {
    Takeout: 'TAKEOUT',
    DineIn: 'DINE_IN'
} as const;

export type ServiceTypeEnum = typeof ServiceTypeEnum[keyof typeof ServiceTypeEnum];


/**
 * * `PENDING` - PENDING * `CONFIRMED` - CONFIRMED * `PREPARING` - PREPARING * `READY` - READY * `COMPLETED` - COMPLETED
 * @export
 * @enum {string}
 */

export const Status514Enum = {
    Pending: 'PENDING',
    Confirmed: 'CONFIRMED',
    Preparing: 'PREPARING',
    Ready: 'READY',
    Completed: 'COMPLETED'
} as const;

export type Status514Enum = typeof Status514Enum[keyof typeof Status514Enum];


/**
 * * `UNREAD` - Unread * `READ` - Read
 * @export
 * @enum {string}
 */

export const Status5d6Enum = {
    Unread: 'UNREAD',
    Read: 'READ'
} as const;

export type Status5d6Enum = typeof Status5d6Enum[keyof typeof Status5d6Enum];


/**
 * Serializer for StockedVenue model
 * @export
 * @interface StockedVenue
 */
export interface StockedVenue {
    /**
     * 
     * @type {string}
     * @memberof StockedVenue
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StockedVenue
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof StockedVenue
     */
    'venue': string;
    /**
     * 
     * @type {Venue}
     * @memberof StockedVenue
     */
    'venue_details': Venue;
    /**
     * 
     * @type {Array<TimeSlot>}
     * @memberof StockedVenue
     */
    'timeslots': Array<TimeSlot>;
    /**
     * 
     * @type {Array<Campaign>}
     * @memberof StockedVenue
     */
    'campaigns': Array<Campaign>;
    /**
     * 
     * @type {string}
     * @memberof StockedVenue
     */
    'date_added': string;
    /**
     * 
     * @type {boolean}
     * @memberof StockedVenue
     */
    'is_favorite'?: boolean;
}
/**
 * Serializer for StockedVenue model
 * @export
 * @interface StockedVenueRequest
 */
export interface StockedVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof StockedVenueRequest
     */
    'venue': string;
    /**
     * 
     * @type {boolean}
     * @memberof StockedVenueRequest
     */
    'is_favorite'?: boolean;
}
/**
 * * `PENDING` - Pending * `CREATED` - Created * `VERIFIED` - Verified * `RESTRICTED` - Restricted * `REJECTED` - Rejected
 * @export
 * @enum {string}
 */

export const StripeAccountStatusEnum = {
    Pending: 'PENDING',
    Created: 'CREATED',
    Verified: 'VERIFIED',
    Restricted: 'RESTRICTED',
    Rejected: 'REJECTED'
} as const;

export type StripeAccountStatusEnum = typeof StripeAccountStatusEnum[keyof typeof StripeAccountStatusEnum];


/**
 * 
 * @export
 * @interface TimeSlot
 */
export interface TimeSlot {
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'end_time': string;
    /**
     * Interval in minutes
     * @type {number}
     * @memberof TimeSlot
     */
    'slot_interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    'max_reservations': number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    'remaining_slots': number;
    /**
     * Number of priority pass slots
     * @type {number}
     * @memberof TimeSlot
     */
    'priority_pass_slot'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'temporary_additional_limit': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'total_current_limit': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof TimeSlot
     */
    'service_type'?: ServiceTypeEnum;
    /**
     * Time frame pause status
     * @type {boolean}
     * @memberof TimeSlot
     */
    'is_paused'?: boolean;
}


/**
 * 
 * @export
 * @interface TimeSlotDailyLimit
 */
export interface TimeSlotDailyLimit {
    /**
     * 
     * @type {string}
     * @memberof TimeSlotDailyLimit
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof TimeSlotDailyLimit
     */
    'temporary_additional_limit'?: number;
}
/**
 * 
 * @export
 * @interface TimeSlotDailyLimitRequest
 */
export interface TimeSlotDailyLimitRequest {
    /**
     * 
     * @type {number}
     * @memberof TimeSlotDailyLimitRequest
     */
    'temporary_additional_limit'?: number;
}
/**
 * 
 * @export
 * @interface TimeSlotRequest
 */
export interface TimeSlotRequest {
    /**
     * 
     * @type {string}
     * @memberof TimeSlotRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlotRequest
     */
    'end_time': string;
    /**
     * Interval in minutes
     * @type {number}
     * @memberof TimeSlotRequest
     */
    'slot_interval'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSlotRequest
     */
    'max_reservations': number;
    /**
     * Number of priority pass slots
     * @type {number}
     * @memberof TimeSlotRequest
     */
    'priority_pass_slot'?: number;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof TimeSlotRequest
     */
    'service_type'?: ServiceTypeEnum;
    /**
     * Time frame pause status
     * @type {boolean}
     * @memberof TimeSlotRequest
     */
    'is_paused'?: boolean;
}


/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh': string;
}
/**
 * Serializer for user profile data
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'ref_code': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_login': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {Array<UserVenueRolesInner>}
     * @memberof User
     */
    'venue_roles': Array<UserVenueRolesInner>;
    /**
     * 
     * @type {Array<Address>}
     * @memberof User
     */
    'addresses': Array<Address>;
}
/**
 * 
 * @export
 * @interface UserCoupon
 */
export interface UserCoupon {
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'user': string;
    /**
     * 
     * @type {Coupon}
     * @memberof UserCoupon
     */
    'coupon': Coupon;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'order'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserCoupon
     */
    'is_used'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'used_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'created_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'expiry_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserCoupon
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface UserCouponRequest
 */
export interface UserCouponRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCouponRequest
     */
    'user': string;
    /**
     * ID of the coupon to assign
     * @type {string}
     * @memberof UserCouponRequest
     */
    'coupon_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserCouponRequest
     */
    'order'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserCouponRequest
     */
    'is_used'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCouponRequest
     */
    'used_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCouponRequest
     */
    'created_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCouponRequest
     */
    'expiry_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCouponRequest
     */
    'note'?: string | null;
}
/**
 * 
 * @export
 * @interface UserLanguage
 */
export interface UserLanguage {
    /**
     * 
     * @type {PreferredLanguageEnum}
     * @memberof UserLanguage
     */
    'preferred_language'?: PreferredLanguageEnum;
}


/**
 * 
 * @export
 * @interface UserLanguageRequest
 */
export interface UserLanguageRequest {
    /**
     * 
     * @type {PreferredLanguageEnum}
     * @memberof UserLanguageRequest
     */
    'preferred_language'?: PreferredLanguageEnum;
}


/**
 * Serializer for updating user profile with limited fields
 * @export
 * @interface UserProfileUpdate
 */
export interface UserProfileUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'phone_number'?: string | null;
}
/**
 * Serializer for updating user profile with limited fields
 * @export
 * @interface UserProfileUpdateRequest
 */
export interface UserProfileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdateRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdateRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {File}
     * @memberof UserProfileUpdateRequest
     */
    'avatar'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdateRequest
     */
    'phone_number'?: string | null;
}
/**
 * Serializer for creating new users
 * @export
 * @interface UserRegistrationRequest
 */
export interface UserRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'password_confirm': string;
    /**
     * 
     * @type {File}
     * @memberof UserRegistrationRequest
     */
    'avatar'?: File | null;
    /**
     * 
     * @type {AddressRegistrationRequest}
     * @memberof UserRegistrationRequest
     */
    'address': AddressRegistrationRequest;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'ref_code'?: string;
}
/**
 * 
 * @export
 * @interface UserVenueRolesInner
 */
export interface UserVenueRolesInner {
    /**
     * 
     * @type {string}
     * @memberof UserVenueRolesInner
     */
    'venue_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserVenueRolesInner
     */
    'venue_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserVenueRolesInner
     */
    'role'?: string;
}
/**
 * * `FIXED_AMOUNT` - Fixed Amount * `PERCENT` - Percent
 * @export
 * @enum {string}
 */

export const ValueTypeEnum = {
    FixedAmount: 'FIXED_AMOUNT',
    Percent: 'PERCENT'
} as const;

export type ValueTypeEnum = typeof ValueTypeEnum[keyof typeof ValueTypeEnum];


/**
 * Serializer for Venue model
 * @export
 * @interface Venue
 */
export interface Venue {
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'announcement'?: string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'website'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'opening_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'enable_reservation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'enable_eat_in'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'enable_take_out'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'enable_order_questions'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'qr_code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'enable_cash_payment'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'enable_online_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'additional_info'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'genre'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Venue
     */
    'buffer_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    'nearest_station'?: string | null;
    /**
     * Absolute application fee amount in JPY for takeout orders
     * @type {number}
     * @memberof Venue
     */
    'custom_platform_fee_amount'?: number | null;
    /**
     * 
     * @type {StripeAccountStatusEnum}
     * @memberof Venue
     */
    'stripe_account_status': StripeAccountStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'onboarding_complete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'payout_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'charges_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    'is_partner': boolean;
}


/**
 * Serializer for ArticleVenueAffiliate
 * @export
 * @interface VenueAffiliate
 */
export interface VenueAffiliate {
    /**
     * 
     * @type {string}
     * @memberof VenueAffiliate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VenueAffiliate
     */
    'venue_id': string;
    /**
     * 
     * @type {string}
     * @memberof VenueAffiliate
     */
    'venue_name': string;
    /**
     * Display title for this venue affiliate
     * @type {string}
     * @memberof VenueAffiliate
     */
    'title': string;
    /**
     * Social media link for this venue
     * @type {string}
     * @memberof VenueAffiliate
     */
    'social_link': string;
    /**
     * Menu link for this venue
     * @type {string}
     * @memberof VenueAffiliate
     */
    'menu_link'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VenueAffiliate
     */
    'order'?: number;
}
/**
 * Serializer for detailed venue information
 * @export
 * @interface VenueDetail
 */
export interface VenueDetail {
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'announcement'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'website'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'opening_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'enable_reservation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'enable_eat_in'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'enable_take_out'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'enable_order_questions'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'logo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'qr_code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'enable_cash_payment'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'enable_online_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'additional_info'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'genre'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VenueDetail
     */
    'buffer_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueDetail
     */
    'nearest_station'?: string | null;
    /**
     * Absolute application fee amount in JPY for takeout orders
     * @type {number}
     * @memberof VenueDetail
     */
    'custom_platform_fee_amount'?: number | null;
    /**
     * 
     * @type {StripeAccountStatusEnum}
     * @memberof VenueDetail
     */
    'stripe_account_status': StripeAccountStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'onboarding_complete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'payout_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'charges_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDetail
     */
    'is_partner': boolean;
}


/**
 * Serializer for VenueQuestion model
 * @export
 * @interface VenueQuestion
 */
export interface VenueQuestion {
    /**
     * 
     * @type {string}
     * @memberof VenueQuestion
     */
    'id': string;
    /**
     * Question (max 255 characters)
     * @type {string}
     * @memberof VenueQuestion
     */
    'question': string;
    /**
     * Order of the question (lower numbers appear first)
     * @type {number}
     * @memberof VenueQuestion
     */
    'ordinal'?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueQuestion
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VenueQuestion
     */
    'updated_at': string;
}
/**
 * Serializer for VenueQuestion model
 * @export
 * @interface VenueQuestionRequest
 */
export interface VenueQuestionRequest {
    /**
     * Question (max 255 characters)
     * @type {string}
     * @memberof VenueQuestionRequest
     */
    'question': string;
    /**
     * Order of the question (lower numbers appear first)
     * @type {number}
     * @memberof VenueQuestionRequest
     */
    'ordinal'?: number;
}
/**
 * Serializer for venue questions configuration - specialized for questions endpoint
 * @export
 * @interface VenueQuestionsConfig
 */
export interface VenueQuestionsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof VenueQuestionsConfig
     */
    'enable_order_questions': boolean;
    /**
     * 
     * @type {Array<VenueQuestion>}
     * @memberof VenueQuestionsConfig
     */
    'questions': Array<VenueQuestion>;
}
/**
 * Serializer for updating venue questions configuration
 * @export
 * @interface VenueQuestionsUpdateRequest
 */
export interface VenueQuestionsUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof VenueQuestionsUpdateRequest
     */
    'enable_order_questions'?: boolean;
    /**
     * 
     * @type {Array<VenueQuestionRequest>}
     * @memberof VenueQuestionsUpdateRequest
     */
    'questions'?: Array<VenueQuestionRequest>;
}
/**
 * Serializer for Venue model
 * @export
 * @interface VenueRequest
 */
export interface VenueRequest {
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'announcement'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'website'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'opening_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'enable_reservation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'enable_eat_in'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'enable_take_out'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'enable_order_questions'?: boolean;
    /**
     * 
     * @type {File}
     * @memberof VenueRequest
     */
    'logo'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'qr_code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'enable_cash_payment'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueRequest
     */
    'enable_online_payment'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'additional_info'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'additional_info_en'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'genre'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'genre_en'?: string;
    /**
     * 
     * @type {number}
     * @memberof VenueRequest
     */
    'buffer_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'nearest_station'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueRequest
     */
    'nearest_station_en'?: string;
    /**
     * Absolute application fee amount in JPY for takeout orders
     * @type {number}
     * @memberof VenueRequest
     */
    'custom_platform_fee_amount'?: number | null;
}
/**
 * Serializer for Stripe Connect account information
 * @export
 * @interface VenueStripeConnect
 */
export interface VenueStripeConnect {
    /**
     * 
     * @type {string}
     * @memberof VenueStripeConnect
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VenueStripeConnect
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VenueStripeConnect
     */
    'stripe_account_id': string | null;
    /**
     * 
     * @type {StripeAccountStatusEnum}
     * @memberof VenueStripeConnect
     */
    'stripe_account_status': StripeAccountStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VenueStripeConnect
     */
    'onboarding_complete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueStripeConnect
     */
    'payout_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueStripeConnect
     */
    'charges_enabled': boolean;
}


/**
 * 
 * @export
 * @interface VenuesStripeConnectCreate200Response
 */
export interface VenuesStripeConnectCreate200Response {
    /**
     * 
     * @type {boolean}
     * @memberof VenuesStripeConnectCreate200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VenuesStripeConnectCreate200Response
     */
    'account_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenuesStripeConnectCreate200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface VenuesStripeConnectOnboardingLinkCreate200Response
 */
export interface VenuesStripeConnectOnboardingLinkCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof VenuesStripeConnectOnboardingLinkCreate200Response
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof VenuesStripeConnectOnboardingLinkCreate200Response
     */
    'expires_at'?: number;
}

/**
 * AreasApi - axios parameter creator
 * @export
 */
export const AreasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of prefectures and their stations
         * @summary List prefectures with stations
         * @param {AreasPrefecturesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPrefecturesRetrieve: async (multilingual?: AreasPrefecturesRetrieveMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/areas/prefectures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AreasApi - functional programming interface
 * @export
 */
export const AreasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AreasApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of prefectures and their stations
         * @summary List prefectures with stations
         * @param {AreasPrefecturesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async areasPrefecturesRetrieve(multilingual?: AreasPrefecturesRetrieveMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.areasPrefecturesRetrieve(multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AreasApi - factory interface
 * @export
 */
export const AreasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AreasApiFp(configuration)
    return {
        /**
         * Returns a list of prefectures and their stations
         * @summary List prefectures with stations
         * @param {AreasPrefecturesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPrefecturesRetrieve(multilingual?: AreasPrefecturesRetrieveMultilingualEnum, options?: any): AxiosPromise<void> {
            return localVarFp.areasPrefecturesRetrieve(multilingual, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AreasApi - interface
 * @export
 * @interface AreasApi
 */
export interface AreasApiInterface {
    /**
     * Returns a list of prefectures and their stations
     * @summary List prefectures with stations
     * @param {AreasPrefecturesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApiInterface
     */
    areasPrefecturesRetrieve(multilingual?: AreasPrefecturesRetrieveMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AreasApi - object-oriented interface
 * @export
 * @class AreasApi
 * @extends {BaseAPI}
 */
export class AreasApi extends BaseAPI implements AreasApiInterface {
    /**
     * Returns a list of prefectures and their stations
     * @summary List prefectures with stations
     * @param {AreasPrefecturesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasPrefecturesRetrieve(multilingual?: AreasPrefecturesRetrieveMultilingualEnum, options?: AxiosRequestConfig) {
        return AreasApiFp(this.configuration).areasPrefecturesRetrieve(multilingual, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AreasPrefecturesRetrieveMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type AreasPrefecturesRetrieveMultilingualEnum = typeof AreasPrefecturesRetrieveMultilingualEnum[keyof typeof AreasPrefecturesRetrieveMultilingualEnum];


/**
 * ArticlesApi - axios parameter creator
 * @export
 */
export const ArticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API view to list all articles with pagination No authentication required
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/articles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view to get article detail by ID No authentication required
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('articlesRetrieve', 'id', id)
            const localVarPath = `/api/articles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * API view to list all articles with pagination No authentication required
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async articlesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedArticleListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.articlesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API view to get article detail by ID No authentication required
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async articlesRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.articlesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticlesApiFp(configuration)
    return {
        /**
         * API view to list all articles with pagination No authentication required
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedArticleListList> {
            return localVarFp.articlesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * API view to get article detail by ID No authentication required
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articlesRetrieve(id: string, options?: any): AxiosPromise<ArticleDetail> {
            return localVarFp.articlesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticlesApi - interface
 * @export
 * @interface ArticlesApi
 */
export interface ArticlesApiInterface {
    /**
     * API view to list all articles with pagination No authentication required
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApiInterface
     */
    articlesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedArticleListList>;

    /**
     * API view to get article detail by ID No authentication required
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApiInterface
     */
    articlesRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<ArticleDetail>;

}

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI implements ArticlesApiInterface {
    /**
     * API view to list all articles with pagination No authentication required
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).articlesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view to get article detail by ID No authentication required
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public articlesRetrieve(id: string, options?: AxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).articlesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new address to the user\'s profile
         * @summary Create new address
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesCreate: async (addressRequest: AddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressRequest' is not null or undefined
            assertParamExists('authAddressesCreate', 'addressRequest', addressRequest)
            const localVarPath = `/api/auth/addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an address from user\'s profile
         * @summary Delete address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authAddressesDestroy', 'id', id)
            const localVarPath = `/api/auth/addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of addresses for the current user
         * @summary List user addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing user addresses
         * @param {string} id 
         * @param {PatchedAddressRequest} [patchedAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesPartialUpdate: async (id: string, patchedAddressRequest?: PatchedAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authAddressesPartialUpdate', 'id', id)
            const localVarPath = `/api/auth/addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about an address
         * @summary Get address details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authAddressesRetrieve', 'id', id)
            const localVarPath = `/api/auth/addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an address as the user\'s default address
         * @summary Set address as default
         * @param {string} id 
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesSetDefaultCreate: async (id: string, addressRequest: AddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authAddressesSetDefaultCreate', 'id', id)
            // verify required parameter 'addressRequest' is not null or undefined
            assertParamExists('authAddressesSetDefaultCreate', 'addressRequest', addressRequest)
            const localVarPath = `/api/auth/addresses/{id}/set_default/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update address information
         * @summary Update address
         * @param {string} id 
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesUpdate: async (id: string, addressRequest: AddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authAddressesUpdate', 'id', id)
            // verify required parameter 'addressRequest' is not null or undefined
            assertParamExists('authAddressesUpdate', 'addressRequest', addressRequest)
            const localVarPath = `/api/auth/addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedUserProfileUpdateRequest} [patchedUserProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMePartialUpdate: async (patchedUserProfileUpdateRequest?: PatchedUserProfileUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates only the name and avatar of the currently authenticated user
         * @summary Update user profile
         * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeUpdate: async (userProfileUpdateRequest: UserProfileUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileUpdateRequest' is not null or undefined
            assertParamExists('authMeUpdate', 'userProfileUpdateRequest', userProfileUpdateRequest)
            const localVarPath = `/api/auth/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s preferred language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPreferredLanguageRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/preferred-language/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user\'s preferred language
         * @param {UserLanguageRequest} [userLanguageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPreferredLanguageUpdate: async (userLanguageRequest?: UserLanguageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/preferred-language/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenCreate: async (tokenRefreshRequest: TokenRefreshRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('authRefreshTokenCreate', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/api/auth/refresh-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PasswordResetRequestRequest} passwordResetRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordCreate: async (passwordResetRequestRequest: PasswordResetRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetRequestRequest' is not null or undefined
            assertParamExists('authResetPasswordCreate', 'passwordResetRequestRequest', passwordResetRequestRequest)
            const localVarPath = `/api/auth/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the current user\'s password by providing current password and new password
         * @summary Change user password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (passwordChangeRequest: PasswordChangeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('changePassword', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/api/auth/change-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the user\'s password using the provided token
         * @summary Confirm password reset
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPasswordReset: async (passwordResetConfirmRequest: PasswordResetConfirmRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetConfirmRequest' is not null or undefined
            assertParamExists('confirmPasswordReset', 'passwordResetConfirmRequest', passwordResetConfirmRequest)
            const localVarPath = `/api/auth/reset-password/confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the profile of the currently authenticated user
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user and return JWT tokens with user data
         * @summary Login and get JWT token
         * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (customTokenObtainPairRequest: CustomTokenObtainPairRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customTokenObtainPairRequest' is not null or undefined
            assertParamExists('login', 'customTokenObtainPairRequest', customTokenObtainPairRequest)
            const localVarPath = `/api/auth/login-user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customTokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user and return JWT tokens with user data
         * @summary Login and get JWT token
         * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login2: async (customTokenObtainPairRequest: CustomTokenObtainPairRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customTokenObtainPairRequest' is not null or undefined
            assertParamExists('login2', 'customTokenObtainPairRequest', customTokenObtainPairRequest)
            const localVarPath = `/api/auth/login-venue/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customTokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account with the provided information including address details
         * @summary Register a new user
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (userRegistrationRequest: UserRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegistrationRequest' is not null or undefined
            assertParamExists('registerUser', 'userRegistrationRequest', userRegistrationRequest)
            const localVarPath = `/api/auth/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new address to the user\'s profile
         * @summary Create new address
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesCreate(addressRequest: AddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesCreate(addressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an address from user\'s profile
         * @summary Delete address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of addresses for the current user
         * @summary List user addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Address>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing user addresses
         * @param {string} id 
         * @param {PatchedAddressRequest} [patchedAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesPartialUpdate(id: string, patchedAddressRequest?: PatchedAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesPartialUpdate(id, patchedAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about an address
         * @summary Get address details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set an address as the user\'s default address
         * @summary Set address as default
         * @param {string} id 
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesSetDefaultCreate(id: string, addressRequest: AddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesSetDefaultCreate(id, addressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update address information
         * @summary Update address
         * @param {string} id 
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authAddressesUpdate(id: string, addressRequest: AddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAddressesUpdate(id, addressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedUserProfileUpdateRequest} [patchedUserProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMePartialUpdate(patchedUserProfileUpdateRequest?: PatchedUserProfileUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMePartialUpdate(patchedUserProfileUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates only the name and avatar of the currently authenticated user
         * @summary Update user profile
         * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeUpdate(userProfileUpdateRequest: UserProfileUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeUpdate(userProfileUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user\'s preferred language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authPreferredLanguageRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLanguage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPreferredLanguageRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user\'s preferred language
         * @param {UserLanguageRequest} [userLanguageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authPreferredLanguageUpdate(userLanguageRequest?: UserLanguageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLanguage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPreferredLanguageUpdate(userLanguageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshTokenCreate(tokenRefreshRequest: TokenRefreshRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshTokenCreate(tokenRefreshRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PasswordResetRequestRequest} passwordResetRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordCreate(passwordResetRequestRequest: PasswordResetRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordCreate(passwordResetRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change the current user\'s password by providing current password and new password
         * @summary Change user password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(passwordChangeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets the user\'s password using the provided token
         * @summary Confirm password reset
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPasswordReset(passwordResetConfirmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the profile of the currently authenticated user
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user and return JWT tokens with user data
         * @summary Login and get JWT token
         * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(customTokenObtainPairRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a user and return JWT tokens with user data
         * @summary Login and get JWT token
         * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login2(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login2(customTokenObtainPairRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new user account with the provided information including address details
         * @summary Register a new user
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(userRegistrationRequest: UserRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(userRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Add a new address to the user\'s profile
         * @summary Create new address
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesCreate(addressRequest: AddressRequest, options?: any): AxiosPromise<Address> {
            return localVarFp.authAddressesCreate(addressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an address from user\'s profile
         * @summary Delete address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.authAddressesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of addresses for the current user
         * @summary List user addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesList(options?: any): AxiosPromise<Array<Address>> {
            return localVarFp.authAddressesList(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing user addresses
         * @param {string} id 
         * @param {PatchedAddressRequest} [patchedAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesPartialUpdate(id: string, patchedAddressRequest?: PatchedAddressRequest, options?: any): AxiosPromise<Address> {
            return localVarFp.authAddressesPartialUpdate(id, patchedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about an address
         * @summary Get address details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesRetrieve(id: string, options?: any): AxiosPromise<Address> {
            return localVarFp.authAddressesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an address as the user\'s default address
         * @summary Set address as default
         * @param {string} id 
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesSetDefaultCreate(id: string, addressRequest: AddressRequest, options?: any): AxiosPromise<Address> {
            return localVarFp.authAddressesSetDefaultCreate(id, addressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update address information
         * @summary Update address
         * @param {string} id 
         * @param {AddressRequest} addressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAddressesUpdate(id: string, addressRequest: AddressRequest, options?: any): AxiosPromise<Address> {
            return localVarFp.authAddressesUpdate(id, addressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedUserProfileUpdateRequest} [patchedUserProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMePartialUpdate(patchedUserProfileUpdateRequest?: PatchedUserProfileUpdateRequest, options?: any): AxiosPromise<UserProfileUpdate> {
            return localVarFp.authMePartialUpdate(patchedUserProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates only the name and avatar of the currently authenticated user
         * @summary Update user profile
         * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeUpdate(userProfileUpdateRequest: UserProfileUpdateRequest, options?: any): AxiosPromise<User> {
            return localVarFp.authMeUpdate(userProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s preferred language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPreferredLanguageRetrieve(options?: any): AxiosPromise<UserLanguage> {
            return localVarFp.authPreferredLanguageRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user\'s preferred language
         * @param {UserLanguageRequest} [userLanguageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPreferredLanguageUpdate(userLanguageRequest?: UserLanguageRequest, options?: any): AxiosPromise<UserLanguage> {
            return localVarFp.authPreferredLanguageUpdate(userLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenCreate(tokenRefreshRequest: TokenRefreshRequest, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.authRefreshTokenCreate(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PasswordResetRequestRequest} passwordResetRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordCreate(passwordResetRequestRequest: PasswordResetRequestRequest, options?: any): AxiosPromise<PasswordResetRequest> {
            return localVarFp.authResetPasswordCreate(passwordResetRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the current user\'s password by providing current password and new password
         * @summary Change user password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(passwordChangeRequest: PasswordChangeRequest, options?: any): AxiosPromise<ChangePassword200Response> {
            return localVarFp.changePassword(passwordChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the user\'s password using the provided token
         * @summary Confirm password reset
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: any): AxiosPromise<void> {
            return localVarFp.confirmPasswordReset(passwordResetConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the profile of the currently authenticated user
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(options?: any): AxiosPromise<User> {
            return localVarFp.getUserProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user and return JWT tokens with user data
         * @summary Login and get JWT token
         * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(customTokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user and return JWT tokens with user data
         * @summary Login and get JWT token
         * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login2(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login2(customTokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account with the provided information including address details
         * @summary Register a new user
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegistrationRequest: UserRegistrationRequest, options?: any): AxiosPromise<User> {
            return localVarFp.registerUser(userRegistrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Add a new address to the user\'s profile
     * @summary Create new address
     * @param {AddressRequest} addressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesCreate(addressRequest: AddressRequest, options?: AxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Delete an address from user\'s profile
     * @summary Delete address
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of addresses for the current user
     * @summary List user addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesList(options?: AxiosRequestConfig): AxiosPromise<Array<Address>>;

    /**
     * API endpoints for managing user addresses
     * @param {string} id 
     * @param {PatchedAddressRequest} [patchedAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesPartialUpdate(id: string, patchedAddressRequest?: PatchedAddressRequest, options?: AxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Get detailed information about an address
     * @summary Get address details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Set an address as the user\'s default address
     * @summary Set address as default
     * @param {string} id 
     * @param {AddressRequest} addressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesSetDefaultCreate(id: string, addressRequest: AddressRequest, options?: AxiosRequestConfig): AxiosPromise<Address>;

    /**
     * Update address information
     * @summary Update address
     * @param {string} id 
     * @param {AddressRequest} addressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authAddressesUpdate(id: string, addressRequest: AddressRequest, options?: AxiosRequestConfig): AxiosPromise<Address>;

    /**
     * 
     * @param {PatchedUserProfileUpdateRequest} [patchedUserProfileUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authMePartialUpdate(patchedUserProfileUpdateRequest?: PatchedUserProfileUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileUpdate>;

    /**
     * Updates only the name and avatar of the currently authenticated user
     * @summary Update user profile
     * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authMeUpdate(userProfileUpdateRequest: UserProfileUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Get user\'s preferred language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authPreferredLanguageRetrieve(options?: AxiosRequestConfig): AxiosPromise<UserLanguage>;

    /**
     * 
     * @summary Update user\'s preferred language
     * @param {UserLanguageRequest} [userLanguageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authPreferredLanguageUpdate(userLanguageRequest?: UserLanguageRequest, options?: AxiosRequestConfig): AxiosPromise<UserLanguage>;

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authRefreshTokenCreate(tokenRefreshRequest: TokenRefreshRequest, options?: AxiosRequestConfig): AxiosPromise<TokenRefresh>;

    /**
     * 
     * @param {PasswordResetRequestRequest} passwordResetRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authResetPasswordCreate(passwordResetRequestRequest: PasswordResetRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PasswordResetRequest>;

    /**
     * Change the current user\'s password by providing current password and new password
     * @summary Change user password
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    changePassword(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig): AxiosPromise<ChangePassword200Response>;

    /**
     * Resets the user\'s password using the provided token
     * @summary Confirm password reset
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the profile of the currently authenticated user
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getUserProfile(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Authenticate a user and return JWT tokens with user data
     * @summary Login and get JWT token
     * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: AxiosRequestConfig): AxiosPromise<LoginResponse>;

    /**
     * Authenticate a user and return JWT tokens with user data
     * @summary Login and get JWT token
     * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login2(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: AxiosRequestConfig): AxiosPromise<LoginResponse>;

    /**
     * Creates a new user account with the provided information including address details
     * @summary Register a new user
     * @param {UserRegistrationRequest} userRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    registerUser(userRegistrationRequest: UserRegistrationRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Add a new address to the user\'s profile
     * @summary Create new address
     * @param {AddressRequest} addressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesCreate(addressRequest: AddressRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesCreate(addressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an address from user\'s profile
     * @summary Delete address
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesDestroy(id: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of addresses for the current user
     * @summary List user addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesList(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing user addresses
     * @param {string} id 
     * @param {PatchedAddressRequest} [patchedAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesPartialUpdate(id: string, patchedAddressRequest?: PatchedAddressRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesPartialUpdate(id, patchedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about an address
     * @summary Get address details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesRetrieve(id: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an address as the user\'s default address
     * @summary Set address as default
     * @param {string} id 
     * @param {AddressRequest} addressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesSetDefaultCreate(id: string, addressRequest: AddressRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesSetDefaultCreate(id, addressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update address information
     * @summary Update address
     * @param {string} id 
     * @param {AddressRequest} addressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authAddressesUpdate(id: string, addressRequest: AddressRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authAddressesUpdate(id, addressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatchedUserProfileUpdateRequest} [patchedUserProfileUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMePartialUpdate(patchedUserProfileUpdateRequest?: PatchedUserProfileUpdateRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMePartialUpdate(patchedUserProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates only the name and avatar of the currently authenticated user
     * @summary Update user profile
     * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMeUpdate(userProfileUpdateRequest: UserProfileUpdateRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMeUpdate(userProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s preferred language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPreferredLanguageRetrieve(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authPreferredLanguageRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user\'s preferred language
     * @param {UserLanguageRequest} [userLanguageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPreferredLanguageUpdate(userLanguageRequest?: UserLanguageRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authPreferredLanguageUpdate(userLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshTokenCreate(tokenRefreshRequest: TokenRefreshRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshTokenCreate(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PasswordResetRequestRequest} passwordResetRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResetPasswordCreate(passwordResetRequestRequest: PasswordResetRequestRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResetPasswordCreate(passwordResetRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the current user\'s password by providing current password and new password
     * @summary Change user password
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePassword(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePassword(passwordChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the user\'s password using the provided token
     * @summary Confirm password reset
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public confirmPasswordReset(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).confirmPasswordReset(passwordResetConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the profile of the currently authenticated user
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserProfile(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getUserProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user and return JWT tokens with user data
     * @summary Login and get JWT token
     * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(customTokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user and return JWT tokens with user data
     * @summary Login and get JWT token
     * @param {CustomTokenObtainPairRequest} customTokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login2(customTokenObtainPairRequest: CustomTokenObtainPairRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login2(customTokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account with the provided information including address details
     * @summary Register a new user
     * @param {UserRegistrationRequest} userRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerUser(userRegistrationRequest: UserRegistrationRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerUser(userRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/campaigns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Campaign>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList(options?: any): AxiosPromise<Array<Campaign>> {
            return localVarFp.campaignsList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - interface
 * @export
 * @interface CampaignsApi
 */
export interface CampaignsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsList(options?: AxiosRequestConfig): AxiosPromise<Array<Campaign>>;

}

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI implements CampaignsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsList(options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CartsApi - axios parameter creator
 * @export
 */
export const CartsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CartRequest} cartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsCreate: async (cartRequest: CartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartRequest' is not null or undefined
            assertParamExists('cartsCreate', 'cartRequest', cartRequest)
            const localVarPath = `/api/carts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartsDestroy', 'id', id)
            const localVarPath = `/api/carts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/carts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {PatchedCartRequest} [patchedCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsPartialUpdate: async (id: string, patchedCartRequest?: PatchedCartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartsPartialUpdate', 'id', id)
            const localVarPath = `/api/carts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartsRetrieve', 'id', id)
            const localVarPath = `/api/carts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {CartRequest} cartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsUpdate: async (id: string, cartRequest: CartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartsUpdate', 'id', id)
            // verify required parameter 'cartRequest' is not null or undefined
            assertParamExists('cartsUpdate', 'cartRequest', cartRequest)
            const localVarPath = `/api/carts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartsApi - functional programming interface
 * @export
 */
export const CartsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CartRequest} cartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartsCreate(cartRequest: CartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartsCreate(cartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartsDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {PatchedCartRequest} [patchedCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartsPartialUpdate(id: string, patchedCartRequest?: PatchedCartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartsPartialUpdate(id, patchedCartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {CartRequest} cartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartsUpdate(id: string, cartRequest: CartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartsUpdate(id, cartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartsApi - factory interface
 * @export
 */
export const CartsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartsApiFp(configuration)
    return {
        /**
         * 
         * @param {CartRequest} cartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsCreate(cartRequest: CartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.cartsCreate(cartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.cartsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsList(options?: any): AxiosPromise<Array<Cart>> {
            return localVarFp.cartsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {PatchedCartRequest} [patchedCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsPartialUpdate(id: string, patchedCartRequest?: PatchedCartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.cartsPartialUpdate(id, patchedCartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsRetrieve(id: string, options?: any): AxiosPromise<Cart> {
            return localVarFp.cartsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this cart.
         * @param {CartRequest} cartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartsUpdate(id: string, cartRequest: CartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.cartsUpdate(id, cartRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartsApi - interface
 * @export
 * @interface CartsApi
 */
export interface CartsApiInterface {
    /**
     * 
     * @param {CartRequest} cartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApiInterface
     */
    cartsCreate(cartRequest: CartRequest, options?: AxiosRequestConfig): AxiosPromise<Cart>;

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApiInterface
     */
    cartsDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApiInterface
     */
    cartsList(options?: AxiosRequestConfig): AxiosPromise<Array<Cart>>;

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {PatchedCartRequest} [patchedCartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApiInterface
     */
    cartsPartialUpdate(id: string, patchedCartRequest?: PatchedCartRequest, options?: AxiosRequestConfig): AxiosPromise<Cart>;

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApiInterface
     */
    cartsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Cart>;

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {CartRequest} cartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApiInterface
     */
    cartsUpdate(id: string, cartRequest: CartRequest, options?: AxiosRequestConfig): AxiosPromise<Cart>;

}

/**
 * CartsApi - object-oriented interface
 * @export
 * @class CartsApi
 * @extends {BaseAPI}
 */
export class CartsApi extends BaseAPI implements CartsApiInterface {
    /**
     * 
     * @param {CartRequest} cartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApi
     */
    public cartsCreate(cartRequest: CartRequest, options?: AxiosRequestConfig) {
        return CartsApiFp(this.configuration).cartsCreate(cartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApi
     */
    public cartsDestroy(id: string, options?: AxiosRequestConfig) {
        return CartsApiFp(this.configuration).cartsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApi
     */
    public cartsList(options?: AxiosRequestConfig) {
        return CartsApiFp(this.configuration).cartsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {PatchedCartRequest} [patchedCartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApi
     */
    public cartsPartialUpdate(id: string, patchedCartRequest?: PatchedCartRequest, options?: AxiosRequestConfig) {
        return CartsApiFp(this.configuration).cartsPartialUpdate(id, patchedCartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApi
     */
    public cartsRetrieve(id: string, options?: AxiosRequestConfig) {
        return CartsApiFp(this.configuration).cartsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this cart.
     * @param {CartRequest} cartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartsApi
     */
    public cartsUpdate(id: string, cartRequest: CartRequest, options?: AxiosRequestConfig) {
        return CartsApiFp(this.configuration).cartsUpdate(id, cartRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CouponsApi - axios parameter creator
 * @export
 */
export const CouponsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of campaign coupons for a specific venue without pagination
         * @summary List campaign coupons by venue
         * @param {string} venueId Venue ID to filter campaign coupons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCampaignCouponsList: async (venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('couponsCampaignCouponsList', 'venueId', venueId)
            const localVarPath = `/api/coupons/campaign-coupons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (venueId !== undefined) {
                localVarQueryParameter['venue_id'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for retrieving campaign coupons by venue.
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCampaignCouponsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsCampaignCouponsRetrieve', 'id', id)
            const localVarPath = `/api/coupons/campaign-coupons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allow authenticated users to claim campaign coupons for themselves
         * @summary Claim campaign coupon
         * @param {string} couponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCampaignUserCouponClaimCreate: async (couponId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'couponId' is not null or undefined
            assertParamExists('couponsCampaignUserCouponClaimCreate', 'couponId', couponId)
            const localVarPath = `/api/coupons/campaign-user-coupon/{coupon_id}/claim/`
                .replace(`{${"coupon_id"}}`, encodeURIComponent(String(couponId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new coupon
         * @summary Create coupon
         * @param {CouponRequest} couponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterCreate: async (couponRequest: CouponRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'couponRequest' is not null or undefined
            assertParamExists('couponsMasterCreate', 'couponRequest', couponRequest)
            const localVarPath = `/api/coupons/master/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsMasterDestroy', 'id', id)
            const localVarPath = `/api/coupons/master/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of coupons
         * @summary List coupons
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [type] Filter by coupon type
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterList: async (page?: number, pageSize?: number, type?: string, venue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/coupons/master/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this coupon.
         * @param {PatchedCouponRequest} [patchedCouponRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterPartialUpdate: async (id: string, patchedCouponRequest?: PatchedCouponRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsMasterPartialUpdate', 'id', id)
            const localVarPath = `/api/coupons/master/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCouponRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific coupon by its ID.
         * @summary Retrieve coupon
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsMasterRetrieve', 'id', id)
            const localVarPath = `/api/coupons/master/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific coupon by its ID.
         * @summary Update coupon
         * @param {string} id A UUID string identifying this coupon.
         * @param {CouponRequest} couponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterUpdate: async (id: string, couponRequest: CouponRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsMasterUpdate', 'id', id)
            // verify required parameter 'couponRequest' is not null or undefined
            assertParamExists('couponsMasterUpdate', 'couponRequest', couponRequest)
            const localVarPath = `/api/coupons/master/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user coupon
         * @summary Create user coupon
         * @param {UserCouponRequest} userCouponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsCreate: async (userCouponRequest: UserCouponRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCouponRequest' is not null or undefined
            assertParamExists('couponsUserCouponsCreate', 'userCouponRequest', userCouponRequest)
            const localVarPath = `/api/coupons/user-coupons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCouponRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific user coupon by its ID
         * @summary Delete user coupon
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsUserCouponsDestroy', 'id', id)
            const localVarPath = `/api/coupons/user-coupons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of user coupons
         * @summary List user coupons
         * @param {string} [user] Filter by user ID
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsList: async (user?: string, venue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/coupons/user-coupons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchedUserCouponRequest} [patchedUserCouponRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsPartialUpdate: async (id: string, patchedUserCouponRequest?: PatchedUserCouponRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsUserCouponsPartialUpdate', 'id', id)
            const localVarPath = `/api/coupons/user-coupons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserCouponRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific user coupon by its ID
         * @summary Retrieve user coupon
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsUserCouponsRetrieve', 'id', id)
            const localVarPath = `/api/coupons/user-coupons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific user coupon by its ID
         * @summary Update user coupon
         * @param {string} id 
         * @param {UserCouponRequest} userCouponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsUpdate: async (id: string, userCouponRequest: UserCouponRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('couponsUserCouponsUpdate', 'id', id)
            // verify required parameter 'userCouponRequest' is not null or undefined
            assertParamExists('couponsUserCouponsUpdate', 'userCouponRequest', userCouponRequest)
            const localVarPath = `/api/coupons/user-coupons/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCouponRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponsApi - functional programming interface
 * @export
 */
export const CouponsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of campaign coupons for a specific venue without pagination
         * @summary List campaign coupons by venue
         * @param {string} venueId Venue ID to filter campaign coupons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsCampaignCouponsList(venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Coupon>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsCampaignCouponsList(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for retrieving campaign coupons by venue.
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsCampaignCouponsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsCampaignCouponsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allow authenticated users to claim campaign coupons for themselves
         * @summary Claim campaign coupon
         * @param {string} couponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsCampaignUserCouponClaimCreate(couponId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsCampaignUserCouponClaimCreate(couponId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new coupon
         * @summary Create coupon
         * @param {CouponRequest} couponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsMasterCreate(couponRequest: CouponRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsMasterCreate(couponRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsMasterDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsMasterDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of coupons
         * @summary List coupons
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [type] Filter by coupon type
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsMasterList(page?: number, pageSize?: number, type?: string, venue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCouponList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsMasterList(page, pageSize, type, venue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this coupon.
         * @param {PatchedCouponRequest} [patchedCouponRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsMasterPartialUpdate(id: string, patchedCouponRequest?: PatchedCouponRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsMasterPartialUpdate(id, patchedCouponRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details of a specific coupon by its ID.
         * @summary Retrieve coupon
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsMasterRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsMasterRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the details of a specific coupon by its ID.
         * @summary Update coupon
         * @param {string} id A UUID string identifying this coupon.
         * @param {CouponRequest} couponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsMasterUpdate(id: string, couponRequest: CouponRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsMasterUpdate(id, couponRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user coupon
         * @summary Create user coupon
         * @param {UserCouponRequest} userCouponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsUserCouponsCreate(userCouponRequest: UserCouponRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsUserCouponsCreate(userCouponRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a specific user coupon by its ID
         * @summary Delete user coupon
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsUserCouponsDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsUserCouponsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of user coupons
         * @summary List user coupons
         * @param {string} [user] Filter by user ID
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsUserCouponsList(user?: string, venue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCoupon>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsUserCouponsList(user, venue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchedUserCouponRequest} [patchedUserCouponRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsUserCouponsPartialUpdate(id: string, patchedUserCouponRequest?: PatchedUserCouponRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsUserCouponsPartialUpdate(id, patchedUserCouponRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details of a specific user coupon by its ID
         * @summary Retrieve user coupon
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsUserCouponsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsUserCouponsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the details of a specific user coupon by its ID
         * @summary Update user coupon
         * @param {string} id 
         * @param {UserCouponRequest} userCouponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsUserCouponsUpdate(id: string, userCouponRequest: UserCouponRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsUserCouponsUpdate(id, userCouponRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponsApi - factory interface
 * @export
 */
export const CouponsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponsApiFp(configuration)
    return {
        /**
         * Retrieve a list of campaign coupons for a specific venue without pagination
         * @summary List campaign coupons by venue
         * @param {string} venueId Venue ID to filter campaign coupons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCampaignCouponsList(venueId: string, options?: any): AxiosPromise<Array<Coupon>> {
            return localVarFp.couponsCampaignCouponsList(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for retrieving campaign coupons by venue.
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCampaignCouponsRetrieve(id: string, options?: any): AxiosPromise<Coupon> {
            return localVarFp.couponsCampaignCouponsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allow authenticated users to claim campaign coupons for themselves
         * @summary Claim campaign coupon
         * @param {string} couponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCampaignUserCouponClaimCreate(couponId: string, options?: any): AxiosPromise<UserCoupon> {
            return localVarFp.couponsCampaignUserCouponClaimCreate(couponId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new coupon
         * @summary Create coupon
         * @param {CouponRequest} couponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterCreate(couponRequest: CouponRequest, options?: any): AxiosPromise<Coupon> {
            return localVarFp.couponsMasterCreate(couponRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.couponsMasterDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of coupons
         * @summary List coupons
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [type] Filter by coupon type
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterList(page?: number, pageSize?: number, type?: string, venue?: string, options?: any): AxiosPromise<PaginatedCouponList> {
            return localVarFp.couponsMasterList(page, pageSize, type, venue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this coupon.
         * @param {PatchedCouponRequest} [patchedCouponRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterPartialUpdate(id: string, patchedCouponRequest?: PatchedCouponRequest, options?: any): AxiosPromise<Coupon> {
            return localVarFp.couponsMasterPartialUpdate(id, patchedCouponRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific coupon by its ID.
         * @summary Retrieve coupon
         * @param {string} id A UUID string identifying this coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterRetrieve(id: string, options?: any): AxiosPromise<Coupon> {
            return localVarFp.couponsMasterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific coupon by its ID.
         * @summary Update coupon
         * @param {string} id A UUID string identifying this coupon.
         * @param {CouponRequest} couponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsMasterUpdate(id: string, couponRequest: CouponRequest, options?: any): AxiosPromise<Coupon> {
            return localVarFp.couponsMasterUpdate(id, couponRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user coupon
         * @summary Create user coupon
         * @param {UserCouponRequest} userCouponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsCreate(userCouponRequest: UserCouponRequest, options?: any): AxiosPromise<UserCoupon> {
            return localVarFp.couponsUserCouponsCreate(userCouponRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific user coupon by its ID
         * @summary Delete user coupon
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.couponsUserCouponsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of user coupons
         * @summary List user coupons
         * @param {string} [user] Filter by user ID
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsList(user?: string, venue?: string, options?: any): AxiosPromise<Array<UserCoupon>> {
            return localVarFp.couponsUserCouponsList(user, venue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchedUserCouponRequest} [patchedUserCouponRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsPartialUpdate(id: string, patchedUserCouponRequest?: PatchedUserCouponRequest, options?: any): AxiosPromise<UserCoupon> {
            return localVarFp.couponsUserCouponsPartialUpdate(id, patchedUserCouponRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific user coupon by its ID
         * @summary Retrieve user coupon
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsRetrieve(id: string, options?: any): AxiosPromise<UserCoupon> {
            return localVarFp.couponsUserCouponsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific user coupon by its ID
         * @summary Update user coupon
         * @param {string} id 
         * @param {UserCouponRequest} userCouponRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsUserCouponsUpdate(id: string, userCouponRequest: UserCouponRequest, options?: any): AxiosPromise<UserCoupon> {
            return localVarFp.couponsUserCouponsUpdate(id, userCouponRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponsApi - interface
 * @export
 * @interface CouponsApi
 */
export interface CouponsApiInterface {
    /**
     * Retrieve a list of campaign coupons for a specific venue without pagination
     * @summary List campaign coupons by venue
     * @param {string} venueId Venue ID to filter campaign coupons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsCampaignCouponsList(venueId: string, options?: AxiosRequestConfig): AxiosPromise<Array<Coupon>>;

    /**
     * ViewSet for retrieving campaign coupons by venue.
     * @param {string} id A UUID string identifying this coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsCampaignCouponsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Coupon>;

    /**
     * Allow authenticated users to claim campaign coupons for themselves
     * @summary Claim campaign coupon
     * @param {string} couponId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsCampaignUserCouponClaimCreate(couponId: string, options?: AxiosRequestConfig): AxiosPromise<UserCoupon>;

    /**
     * Create a new coupon
     * @summary Create coupon
     * @param {CouponRequest} couponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsMasterCreate(couponRequest: CouponRequest, options?: AxiosRequestConfig): AxiosPromise<Coupon>;

    /**
     * 
     * @param {string} id A UUID string identifying this coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsMasterDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a list of coupons
     * @summary List coupons
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [type] Filter by coupon type
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsMasterList(page?: number, pageSize?: number, type?: string, venue?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedCouponList>;

    /**
     * 
     * @param {string} id A UUID string identifying this coupon.
     * @param {PatchedCouponRequest} [patchedCouponRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsMasterPartialUpdate(id: string, patchedCouponRequest?: PatchedCouponRequest, options?: AxiosRequestConfig): AxiosPromise<Coupon>;

    /**
     * Retrieve details of a specific coupon by its ID.
     * @summary Retrieve coupon
     * @param {string} id A UUID string identifying this coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsMasterRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Coupon>;

    /**
     * Update the details of a specific coupon by its ID.
     * @summary Update coupon
     * @param {string} id A UUID string identifying this coupon.
     * @param {CouponRequest} couponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsMasterUpdate(id: string, couponRequest: CouponRequest, options?: AxiosRequestConfig): AxiosPromise<Coupon>;

    /**
     * Create a new user coupon
     * @summary Create user coupon
     * @param {UserCouponRequest} userCouponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsUserCouponsCreate(userCouponRequest: UserCouponRequest, options?: AxiosRequestConfig): AxiosPromise<UserCoupon>;

    /**
     * Delete a specific user coupon by its ID
     * @summary Delete user coupon
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsUserCouponsDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a list of user coupons
     * @summary List user coupons
     * @param {string} [user] Filter by user ID
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsUserCouponsList(user?: string, venue?: string, options?: AxiosRequestConfig): AxiosPromise<Array<UserCoupon>>;

    /**
     * 
     * @param {string} id 
     * @param {PatchedUserCouponRequest} [patchedUserCouponRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsUserCouponsPartialUpdate(id: string, patchedUserCouponRequest?: PatchedUserCouponRequest, options?: AxiosRequestConfig): AxiosPromise<UserCoupon>;

    /**
     * Retrieve details of a specific user coupon by its ID
     * @summary Retrieve user coupon
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsUserCouponsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<UserCoupon>;

    /**
     * Update the details of a specific user coupon by its ID
     * @summary Update user coupon
     * @param {string} id 
     * @param {UserCouponRequest} userCouponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApiInterface
     */
    couponsUserCouponsUpdate(id: string, userCouponRequest: UserCouponRequest, options?: AxiosRequestConfig): AxiosPromise<UserCoupon>;

}

/**
 * CouponsApi - object-oriented interface
 * @export
 * @class CouponsApi
 * @extends {BaseAPI}
 */
export class CouponsApi extends BaseAPI implements CouponsApiInterface {
    /**
     * Retrieve a list of campaign coupons for a specific venue without pagination
     * @summary List campaign coupons by venue
     * @param {string} venueId Venue ID to filter campaign coupons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsCampaignCouponsList(venueId: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsCampaignCouponsList(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for retrieving campaign coupons by venue.
     * @param {string} id A UUID string identifying this coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsCampaignCouponsRetrieve(id: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsCampaignCouponsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allow authenticated users to claim campaign coupons for themselves
     * @summary Claim campaign coupon
     * @param {string} couponId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsCampaignUserCouponClaimCreate(couponId: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsCampaignUserCouponClaimCreate(couponId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new coupon
     * @summary Create coupon
     * @param {CouponRequest} couponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsMasterCreate(couponRequest: CouponRequest, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsMasterCreate(couponRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsMasterDestroy(id: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsMasterDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of coupons
     * @summary List coupons
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [type] Filter by coupon type
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsMasterList(page?: number, pageSize?: number, type?: string, venue?: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsMasterList(page, pageSize, type, venue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this coupon.
     * @param {PatchedCouponRequest} [patchedCouponRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsMasterPartialUpdate(id: string, patchedCouponRequest?: PatchedCouponRequest, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsMasterPartialUpdate(id, patchedCouponRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific coupon by its ID.
     * @summary Retrieve coupon
     * @param {string} id A UUID string identifying this coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsMasterRetrieve(id: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsMasterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific coupon by its ID.
     * @summary Update coupon
     * @param {string} id A UUID string identifying this coupon.
     * @param {CouponRequest} couponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsMasterUpdate(id: string, couponRequest: CouponRequest, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsMasterUpdate(id, couponRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user coupon
     * @summary Create user coupon
     * @param {UserCouponRequest} userCouponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsUserCouponsCreate(userCouponRequest: UserCouponRequest, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsUserCouponsCreate(userCouponRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific user coupon by its ID
     * @summary Delete user coupon
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsUserCouponsDestroy(id: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsUserCouponsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of user coupons
     * @summary List user coupons
     * @param {string} [user] Filter by user ID
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsUserCouponsList(user?: string, venue?: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsUserCouponsList(user, venue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchedUserCouponRequest} [patchedUserCouponRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsUserCouponsPartialUpdate(id: string, patchedUserCouponRequest?: PatchedUserCouponRequest, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsUserCouponsPartialUpdate(id, patchedUserCouponRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific user coupon by its ID
     * @summary Retrieve user coupon
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsUserCouponsRetrieve(id: string, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsUserCouponsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific user coupon by its ID
     * @summary Update user coupon
     * @param {string} id 
     * @param {UserCouponRequest} userCouponRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public couponsUserCouponsUpdate(id: string, userCouponRequest: UserCouponRequest, options?: AxiosRequestConfig) {
        return CouponsApiFp(this.configuration).couponsUserCouponsUpdate(id, userCouponRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deactivate an FCM token (e.g., when user logs out)
         * @summary Deactivate FCM token
         * @param {string} id 
         * @param {FCMTokenRequest} fCMTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFcmToken: async (id: string, fCMTokenRequest: FCMTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateFcmToken', 'id', id)
            // verify required parameter 'fCMTokenRequest' is not null or undefined
            assertParamExists('deactivateFcmToken', 'fCMTokenRequest', fCMTokenRequest)
            const localVarPath = `/api/notifications/tokens/{id}/deactivate/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fCMTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of notifications for the current user
         * @summary List user notifications
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [status] Filter by read status
         * @param {string} [type] Filter by notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsList: async (page?: number, pageSize?: number, status?: string, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all notifications of the current user as read
         * @summary Mark all notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsReadAllUpdate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/read_all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a notification as read
         * @summary Mark notification as read
         * @param {string} id 
         * @param {NotificationReadStatusRequest} [notificationReadStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsReadUpdate: async (id: string, notificationReadStatusRequest?: NotificationReadStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsReadUpdate', 'id', id)
            const localVarPath = `/api/notifications/{id}/read/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationReadStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a notification
         * @summary Get notification details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsRetrieve', 'id', id)
            const localVarPath = `/api/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for managing FCM tokens for push notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsTokensList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for managing FCM tokens for push notifications
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsTokensRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsTokensRetrieve', 'id', id)
            const localVarPath = `/api/notifications/tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get count of reservations and orders with time slots starting in the next 30 minutes.
         * @summary Get upcoming reservation and order counts for venue
         * @param {string} venueId Filter by venue ID (required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpcomingReservationsRetrieve: async (venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('notificationsUpcomingReservationsRetrieve', 'venueId', venueId)
            const localVarPath = `/api/notifications/upcoming_reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (venueId !== undefined) {
                localVarQueryParameter['venue_id'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new Firebase Cloud Messaging token for push notifications
         * @summary Register FCM token
         * @param {FCMTokenRegistrationRequest} fCMTokenRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFcmToken: async (fCMTokenRegistrationRequest: FCMTokenRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fCMTokenRegistrationRequest' is not null or undefined
            assertParamExists('registerFcmToken', 'fCMTokenRegistrationRequest', fCMTokenRegistrationRequest)
            const localVarPath = `/api/notifications/tokens/register/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fCMTokenRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deactivate an FCM token (e.g., when user logs out)
         * @summary Deactivate FCM token
         * @param {string} id 
         * @param {FCMTokenRequest} fCMTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateFcmToken(id: string, fCMTokenRequest: FCMTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateFcmToken(id, fCMTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a paginated list of notifications for the current user
         * @summary List user notifications
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [status] Filter by read status
         * @param {string} [type] Filter by notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsList(page?: number, pageSize?: number, status?: string, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsList(page, pageSize, status, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all notifications of the current user as read
         * @summary Mark all notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsReadAllUpdate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsReadAllUpdate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark a notification as read
         * @summary Mark notification as read
         * @param {string} id 
         * @param {NotificationReadStatusRequest} [notificationReadStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsReadUpdate(id: string, notificationReadStatusRequest?: NotificationReadStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationReadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsReadUpdate(id, notificationReadStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about a notification
         * @summary Get notification details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for managing FCM tokens for push notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsTokensList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FCMToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsTokensList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for managing FCM tokens for push notifications
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsTokensRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FCMToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsTokensRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get count of reservations and orders with time slots starting in the next 30 minutes.
         * @summary Get upcoming reservation and order counts for venue
         * @param {string} venueId Filter by venue ID (required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsUpcomingReservationsRetrieve(venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsUpcomingReservationsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsUpcomingReservationsRetrieve(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register a new Firebase Cloud Messaging token for push notifications
         * @summary Register FCM token
         * @param {FCMTokenRegistrationRequest} fCMTokenRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerFcmToken(fCMTokenRegistrationRequest: FCMTokenRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FCMToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerFcmToken(fCMTokenRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Deactivate an FCM token (e.g., when user logs out)
         * @summary Deactivate FCM token
         * @param {string} id 
         * @param {FCMTokenRequest} fCMTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFcmToken(id: string, fCMTokenRequest: FCMTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateFcmToken(id, fCMTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of notifications for the current user
         * @summary List user notifications
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [status] Filter by read status
         * @param {string} [type] Filter by notification type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsList(page?: number, pageSize?: number, status?: string, type?: string, options?: any): AxiosPromise<PaginatedNotificationList> {
            return localVarFp.notificationsList(page, pageSize, status, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark all notifications of the current user as read
         * @summary Mark all notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsReadAllUpdate(options?: any): AxiosPromise<void> {
            return localVarFp.notificationsReadAllUpdate(options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a notification as read
         * @summary Mark notification as read
         * @param {string} id 
         * @param {NotificationReadStatusRequest} [notificationReadStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsReadUpdate(id: string, notificationReadStatusRequest?: NotificationReadStatusRequest, options?: any): AxiosPromise<NotificationReadStatus> {
            return localVarFp.notificationsReadUpdate(id, notificationReadStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a notification
         * @summary Get notification details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsRetrieve(id: string, options?: any): AxiosPromise<Notification> {
            return localVarFp.notificationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for managing FCM tokens for push notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsTokensList(options?: any): AxiosPromise<Array<FCMToken>> {
            return localVarFp.notificationsTokensList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for managing FCM tokens for push notifications
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsTokensRetrieve(id: string, options?: any): AxiosPromise<FCMToken> {
            return localVarFp.notificationsTokensRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get count of reservations and orders with time slots starting in the next 30 minutes.
         * @summary Get upcoming reservation and order counts for venue
         * @param {string} venueId Filter by venue ID (required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpcomingReservationsRetrieve(venueId: string, options?: any): AxiosPromise<NotificationsUpcomingReservationsRetrieve200Response> {
            return localVarFp.notificationsUpcomingReservationsRetrieve(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new Firebase Cloud Messaging token for push notifications
         * @summary Register FCM token
         * @param {FCMTokenRegistrationRequest} fCMTokenRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFcmToken(fCMTokenRegistrationRequest: FCMTokenRegistrationRequest, options?: any): AxiosPromise<FCMToken> {
            return localVarFp.registerFcmToken(fCMTokenRegistrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - interface
 * @export
 * @interface NotificationsApi
 */
export interface NotificationsApiInterface {
    /**
     * Deactivate an FCM token (e.g., when user logs out)
     * @summary Deactivate FCM token
     * @param {string} id 
     * @param {FCMTokenRequest} fCMTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    deactivateFcmToken(id: string, fCMTokenRequest: FCMTokenRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a paginated list of notifications for the current user
     * @summary List user notifications
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of results per page (max 100)
     * @param {string} [status] Filter by read status
     * @param {string} [type] Filter by notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsList(page?: number, pageSize?: number, status?: string, type?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedNotificationList>;

    /**
     * Mark all notifications of the current user as read
     * @summary Mark all notifications as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsReadAllUpdate(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Mark a notification as read
     * @summary Mark notification as read
     * @param {string} id 
     * @param {NotificationReadStatusRequest} [notificationReadStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsReadUpdate(id: string, notificationReadStatusRequest?: NotificationReadStatusRequest, options?: AxiosRequestConfig): AxiosPromise<NotificationReadStatus>;

    /**
     * Get detailed information about a notification
     * @summary Get notification details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Notification>;

    /**
     * ViewSet for managing FCM tokens for push notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsTokensList(options?: AxiosRequestConfig): AxiosPromise<Array<FCMToken>>;

    /**
     * ViewSet for managing FCM tokens for push notifications
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsTokensRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<FCMToken>;

    /**
     * Get count of reservations and orders with time slots starting in the next 30 minutes.
     * @summary Get upcoming reservation and order counts for venue
     * @param {string} venueId Filter by venue ID (required)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    notificationsUpcomingReservationsRetrieve(venueId: string, options?: AxiosRequestConfig): AxiosPromise<NotificationsUpcomingReservationsRetrieve200Response>;

    /**
     * Register a new Firebase Cloud Messaging token for push notifications
     * @summary Register FCM token
     * @param {FCMTokenRegistrationRequest} fCMTokenRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    registerFcmToken(fCMTokenRegistrationRequest: FCMTokenRegistrationRequest, options?: AxiosRequestConfig): AxiosPromise<FCMToken>;

}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI implements NotificationsApiInterface {
    /**
     * Deactivate an FCM token (e.g., when user logs out)
     * @summary Deactivate FCM token
     * @param {string} id 
     * @param {FCMTokenRequest} fCMTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deactivateFcmToken(id: string, fCMTokenRequest: FCMTokenRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deactivateFcmToken(id, fCMTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of notifications for the current user
     * @summary List user notifications
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of results per page (max 100)
     * @param {string} [status] Filter by read status
     * @param {string} [type] Filter by notification type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsList(page?: number, pageSize?: number, status?: string, type?: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsList(page, pageSize, status, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all notifications of the current user as read
     * @summary Mark all notifications as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsReadAllUpdate(options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsReadAllUpdate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a notification as read
     * @summary Mark notification as read
     * @param {string} id 
     * @param {NotificationReadStatusRequest} [notificationReadStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsReadUpdate(id: string, notificationReadStatusRequest?: NotificationReadStatusRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsReadUpdate(id, notificationReadStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a notification
     * @summary Get notification details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsRetrieve(id: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for managing FCM tokens for push notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsTokensList(options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsTokensList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for managing FCM tokens for push notifications
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsTokensRetrieve(id: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsTokensRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get count of reservations and orders with time slots starting in the next 30 minutes.
     * @summary Get upcoming reservation and order counts for venue
     * @param {string} venueId Filter by venue ID (required)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsUpcomingReservationsRetrieve(venueId: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsUpcomingReservationsRetrieve(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new Firebase Cloud Messaging token for push notifications
     * @summary Register FCM token
     * @param {FCMTokenRegistrationRequest} fCMTokenRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public registerFcmToken(fCMTokenRegistrationRequest: FCMTokenRegistrationRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).registerFcmToken(fCMTokenRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk confirm pickup for multiple orders (venue managers only). All orders must be in READY state.
         * @summary Bulk confirm order pickup
         * @param {BulkOrderConfirmPickupRequest} bulkOrderConfirmPickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersBulkConfirmPickupCreate: async (bulkOrderConfirmPickupRequest: BulkOrderConfirmPickupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOrderConfirmPickupRequest' is not null or undefined
            assertParamExists('ordersBulkConfirmPickupCreate', 'bulkOrderConfirmPickupRequest', bulkOrderConfirmPickupRequest)
            const localVarPath = `/api/orders/bulk-confirm-pickup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOrderConfirmPickupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk update status for multiple orders (venue managers only). Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
         * @summary Bulk update order status
         * @param {BulkOrderStatusRequest} bulkOrderStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersBulkStatusUpdate: async (bulkOrderStatusRequest: BulkOrderStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOrderStatusRequest' is not null or undefined
            assertParamExists('ordersBulkStatusUpdate', 'bulkOrderStatusRequest', bulkOrderStatusRequest)
            const localVarPath = `/api/orders/bulk-status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOrderStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of orders filtered by a specific venue ID. Only accessible to venue staff (owners, managers, or staff).
         * @summary List orders by venue
         * @param {string} venueId ID of the venue to filter orders by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersByVenueRetrieve: async (venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('ordersByVenueRetrieve', 'venueId', venueId)
            const localVarPath = `/api/orders/by-venue/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (venueId !== undefined) {
                localVarQueryParameter['venue_id'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark an order as completed after confirming pickup with the customer.
         * @summary Confirm order pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersConfirmPickupCreate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersConfirmPickupCreate', 'id', id)
            const localVarPath = `/api/orders/{id}/confirm_pickup/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order with menu items
         * @summary Create order
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCreate: async (orderCreateRequest: OrderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreateRequest' is not null or undefined
            assertParamExists('ordersCreate', 'orderCreateRequest', orderCreateRequest)
            const localVarPath = `/api/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an order (only for the order owner or venue manager)
         * @summary Cancel order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersDestroy', 'id', id)
            const localVarPath = `/api/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of orders for the current user or orders from venues the user manages
         * @summary List user orders
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {string} [orderType] Filter by order type
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by order status (can be a comma-separated list of statuses)
         * @param {string} [timeSlot] Filter by time slot
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersList: async (endDate?: string, orderType?: string, page?: number, pageSize?: number, startDate?: string, status?: string, timeSlot?: string, venue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (timeSlot !== undefined) {
                localVarQueryParameter['time_slot'] = timeSlot;
            }

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve orders by current user.
         * @summary List orders by current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersMyOrdersRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orders/my-orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing orders
         * @param {string} id 
         * @param {PatchedOrderRequest} [patchedOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPartialUpdate: async (id: string, patchedOrderRequest?: PatchedOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersPartialUpdate', 'id', id)
            const localVarPath = `/api/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a payment for a specific order
         * @summary Create order payment
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPayCreate: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersPayCreate', 'orderId', orderId)
            const localVarPath = `/api/orders/{order_id}/pay/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about an order
         * @summary Get order details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersRetrieve', 'id', id)
            const localVarPath = `/api/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for viewing order status history.
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersStatusHistoryList: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersStatusHistoryList', 'orderId', orderId)
            const localVarPath = `/api/orders/{order_id}/status-history/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of an order (venue managers only)
         * @summary Update order status
         * @param {string} id 
         * @param {OrderStatusUpdateRequest} [orderStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersStatusUpdate: async (id: string, orderStatusUpdateRequest?: OrderStatusUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersStatusUpdate', 'id', id)
            const localVarPath = `/api/orders/{id}/status/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderStatusUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific order by its ID.
         * @summary Update order
         * @param {string} id 
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersUpdate: async (id: string, orderCreateRequest: OrderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersUpdate', 'id', id)
            // verify required parameter 'orderCreateRequest' is not null or undefined
            assertParamExists('ordersUpdate', 'orderCreateRequest', orderCreateRequest)
            const localVarPath = `/api/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk confirm pickup for multiple orders (venue managers only). All orders must be in READY state.
         * @summary Bulk confirm order pickup
         * @param {BulkOrderConfirmPickupRequest} bulkOrderConfirmPickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest: BulkOrderConfirmPickupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bulk update status for multiple orders (venue managers only). Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
         * @summary Bulk update order status
         * @param {BulkOrderStatusRequest} bulkOrderStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersBulkStatusUpdate(bulkOrderStatusRequest: BulkOrderStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersBulkStatusUpdate(bulkOrderStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of orders filtered by a specific venue ID. Only accessible to venue staff (owners, managers, or staff).
         * @summary List orders by venue
         * @param {string} venueId ID of the venue to filter orders by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersByVenueRetrieve(venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersByVenueRetrieve(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark an order as completed after confirming pickup with the customer.
         * @summary Confirm order pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersConfirmPickupCreate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersConfirmPickupCreate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new order with menu items
         * @summary Create order
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersCreate(orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersCreate(orderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel an order (only for the order owner or venue manager)
         * @summary Cancel order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of orders for the current user or orders from venues the user manages
         * @summary List user orders
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {string} [orderType] Filter by order type
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by order status (can be a comma-separated list of statuses)
         * @param {string} [timeSlot] Filter by time slot
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersList(endDate?: string, orderType?: string, page?: number, pageSize?: number, startDate?: string, status?: string, timeSlot?: string, venue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersList(endDate, orderType, page, pageSize, startDate, status, timeSlot, venue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve orders by current user.
         * @summary List orders by current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersMyOrdersRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersMyOrdersRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing orders
         * @param {string} id 
         * @param {PatchedOrderRequest} [patchedOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPartialUpdate(id: string, patchedOrderRequest?: PatchedOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPartialUpdate(id, patchedOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a payment for a specific order
         * @summary Create order payment
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPayCreate(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersPayCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPayCreate(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about an order
         * @summary Get order details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for viewing order status history.
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersStatusHistoryList(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderStatusHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersStatusHistoryList(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the status of an order (venue managers only)
         * @summary Update order status
         * @param {string} id 
         * @param {OrderStatusUpdateRequest} [orderStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersStatusUpdate(id: string, orderStatusUpdateRequest?: OrderStatusUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersStatusUpdate(id, orderStatusUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the details of a specific order by its ID.
         * @summary Update order
         * @param {string} id 
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersUpdate(id: string, orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersUpdate(id, orderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Bulk confirm pickup for multiple orders (venue managers only). All orders must be in READY state.
         * @summary Bulk confirm order pickup
         * @param {BulkOrderConfirmPickupRequest} bulkOrderConfirmPickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest: BulkOrderConfirmPickupRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk update status for multiple orders (venue managers only). Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
         * @summary Bulk update order status
         * @param {BulkOrderStatusRequest} bulkOrderStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersBulkStatusUpdate(bulkOrderStatusRequest: BulkOrderStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ordersBulkStatusUpdate(bulkOrderStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of orders filtered by a specific venue ID. Only accessible to venue staff (owners, managers, or staff).
         * @summary List orders by venue
         * @param {string} venueId ID of the venue to filter orders by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersByVenueRetrieve(venueId: string, options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.ordersByVenueRetrieve(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark an order as completed after confirming pickup with the customer.
         * @summary Confirm order pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersConfirmPickupCreate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.ordersConfirmPickupCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order with menu items
         * @summary Create order
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCreate(orderCreateRequest: OrderCreateRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.ordersCreate(orderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an order (only for the order owner or venue manager)
         * @summary Cancel order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.ordersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of orders for the current user or orders from venues the user manages
         * @summary List user orders
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {string} [orderType] Filter by order type
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by order status (can be a comma-separated list of statuses)
         * @param {string} [timeSlot] Filter by time slot
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersList(endDate?: string, orderType?: string, page?: number, pageSize?: number, startDate?: string, status?: string, timeSlot?: string, venue?: string, options?: any): AxiosPromise<PaginatedOrderListList> {
            return localVarFp.ordersList(endDate, orderType, page, pageSize, startDate, status, timeSlot, venue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve orders by current user.
         * @summary List orders by current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersMyOrdersRetrieve(options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.ordersMyOrdersRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing orders
         * @param {string} id 
         * @param {PatchedOrderRequest} [patchedOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPartialUpdate(id: string, patchedOrderRequest?: PatchedOrderRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.ordersPartialUpdate(id, patchedOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a payment for a specific order
         * @summary Create order payment
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPayCreate(orderId: string, options?: any): AxiosPromise<OrdersPayCreate200Response> {
            return localVarFp.ordersPayCreate(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about an order
         * @summary Get order details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersRetrieve(id: string, options?: any): AxiosPromise<Order> {
            return localVarFp.ordersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for viewing order status history.
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersStatusHistoryList(orderId: string, options?: any): AxiosPromise<Array<OrderStatusHistory>> {
            return localVarFp.ordersStatusHistoryList(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of an order (venue managers only)
         * @summary Update order status
         * @param {string} id 
         * @param {OrderStatusUpdateRequest} [orderStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersStatusUpdate(id: string, orderStatusUpdateRequest?: OrderStatusUpdateRequest, options?: any): AxiosPromise<OrderStatusUpdate> {
            return localVarFp.ordersStatusUpdate(id, orderStatusUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific order by its ID.
         * @summary Update order
         * @param {string} id 
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersUpdate(id: string, orderCreateRequest: OrderCreateRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.ordersUpdate(id, orderCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - interface
 * @export
 * @interface OrdersApi
 */
export interface OrdersApiInterface {
    /**
     * Bulk confirm pickup for multiple orders (venue managers only). All orders must be in READY state.
     * @summary Bulk confirm order pickup
     * @param {BulkOrderConfirmPickupRequest} bulkOrderConfirmPickupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest: BulkOrderConfirmPickupRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Bulk update status for multiple orders (venue managers only). Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
     * @summary Bulk update order status
     * @param {BulkOrderStatusRequest} bulkOrderStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersBulkStatusUpdate(bulkOrderStatusRequest: BulkOrderStatusRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a list of orders filtered by a specific venue ID. Only accessible to venue staff (owners, managers, or staff).
     * @summary List orders by venue
     * @param {string} venueId ID of the venue to filter orders by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersByVenueRetrieve(venueId: string, options?: AxiosRequestConfig): AxiosPromise<Array<Order>>;

    /**
     * Mark an order as completed after confirming pickup with the customer.
     * @summary Confirm order pickup
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersConfirmPickupCreate(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Create a new order with menu items
     * @summary Create order
     * @param {OrderCreateRequest} orderCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersCreate(orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * Cancel an order (only for the order owner or venue manager)
     * @summary Cancel order
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of orders for the current user or orders from venues the user manages
     * @summary List user orders
     * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
     * @param {string} [orderType] Filter by order type
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of results per page (max 100)
     * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
     * @param {string} [status] Filter by order status (can be a comma-separated list of statuses)
     * @param {string} [timeSlot] Filter by time slot
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersList(endDate?: string, orderType?: string, page?: number, pageSize?: number, startDate?: string, status?: string, timeSlot?: string, venue?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderListList>;

    /**
     * Retrieve orders by current user.
     * @summary List orders by current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersMyOrdersRetrieve(options?: AxiosRequestConfig): AxiosPromise<Array<Order>>;

    /**
     * API endpoints for managing orders
     * @param {string} id 
     * @param {PatchedOrderRequest} [patchedOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersPartialUpdate(id: string, patchedOrderRequest?: PatchedOrderRequest, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * Create a payment for a specific order
     * @summary Create order payment
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersPayCreate(orderId: string, options?: AxiosRequestConfig): AxiosPromise<OrdersPayCreate200Response>;

    /**
     * Get detailed information about an order
     * @summary Get order details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * API endpoints for viewing order status history.
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersStatusHistoryList(orderId: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrderStatusHistory>>;

    /**
     * Update the status of an order (venue managers only)
     * @summary Update order status
     * @param {string} id 
     * @param {OrderStatusUpdateRequest} [orderStatusUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersStatusUpdate(id: string, orderStatusUpdateRequest?: OrderStatusUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<OrderStatusUpdate>;

    /**
     * Update the details of a specific order by its ID.
     * @summary Update order
     * @param {string} id 
     * @param {OrderCreateRequest} orderCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    ordersUpdate(id: string, orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig): AxiosPromise<Order>;

}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI implements OrdersApiInterface {
    /**
     * Bulk confirm pickup for multiple orders (venue managers only). All orders must be in READY state.
     * @summary Bulk confirm order pickup
     * @param {BulkOrderConfirmPickupRequest} bulkOrderConfirmPickupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest: BulkOrderConfirmPickupRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersBulkConfirmPickupCreate(bulkOrderConfirmPickupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk update status for multiple orders (venue managers only). Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
     * @summary Bulk update order status
     * @param {BulkOrderStatusRequest} bulkOrderStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersBulkStatusUpdate(bulkOrderStatusRequest: BulkOrderStatusRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersBulkStatusUpdate(bulkOrderStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of orders filtered by a specific venue ID. Only accessible to venue staff (owners, managers, or staff).
     * @summary List orders by venue
     * @param {string} venueId ID of the venue to filter orders by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersByVenueRetrieve(venueId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersByVenueRetrieve(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark an order as completed after confirming pickup with the customer.
     * @summary Confirm order pickup
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersConfirmPickupCreate(id: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersConfirmPickupCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order with menu items
     * @summary Create order
     * @param {OrderCreateRequest} orderCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersCreate(orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersCreate(orderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an order (only for the order owner or venue manager)
     * @summary Cancel order
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersDestroy(id: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of orders for the current user or orders from venues the user manages
     * @summary List user orders
     * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
     * @param {string} [orderType] Filter by order type
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of results per page (max 100)
     * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
     * @param {string} [status] Filter by order status (can be a comma-separated list of statuses)
     * @param {string} [timeSlot] Filter by time slot
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersList(endDate?: string, orderType?: string, page?: number, pageSize?: number, startDate?: string, status?: string, timeSlot?: string, venue?: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersList(endDate, orderType, page, pageSize, startDate, status, timeSlot, venue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve orders by current user.
     * @summary List orders by current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersMyOrdersRetrieve(options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersMyOrdersRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing orders
     * @param {string} id 
     * @param {PatchedOrderRequest} [patchedOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPartialUpdate(id: string, patchedOrderRequest?: PatchedOrderRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPartialUpdate(id, patchedOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a payment for a specific order
     * @summary Create order payment
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPayCreate(orderId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPayCreate(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about an order
     * @summary Get order details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersRetrieve(id: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for viewing order status history.
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersStatusHistoryList(orderId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersStatusHistoryList(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of an order (venue managers only)
     * @summary Update order status
     * @param {string} id 
     * @param {OrderStatusUpdateRequest} [orderStatusUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersStatusUpdate(id: string, orderStatusUpdateRequest?: OrderStatusUpdateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersStatusUpdate(id, orderStatusUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific order by its ID.
     * @summary Update order
     * @param {string} id 
     * @param {OrderCreateRequest} orderCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersUpdate(id: string, orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersUpdate(id, orderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerStoresApi - axios parameter creator
 * @export
 */
export const PartnerStoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API view to list all partner stores No authentication required Ordered by order field (ascending) then by creation date (LIFO - newest first)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStoresList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/partner-stores/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerStoresApi - functional programming interface
 * @export
 */
export const PartnerStoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerStoresApiAxiosParamCreator(configuration)
    return {
        /**
         * API view to list all partner stores No authentication required Ordered by order field (ascending) then by creation date (LIFO - newest first)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerStoresList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PartnerStore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerStoresList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnerStoresApi - factory interface
 * @export
 */
export const PartnerStoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerStoresApiFp(configuration)
    return {
        /**
         * API view to list all partner stores No authentication required Ordered by order field (ascending) then by creation date (LIFO - newest first)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerStoresList(options?: any): AxiosPromise<Array<PartnerStore>> {
            return localVarFp.partnerStoresList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerStoresApi - interface
 * @export
 * @interface PartnerStoresApi
 */
export interface PartnerStoresApiInterface {
    /**
     * API view to list all partner stores No authentication required Ordered by order field (ascending) then by creation date (LIFO - newest first)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerStoresApiInterface
     */
    partnerStoresList(options?: AxiosRequestConfig): AxiosPromise<Array<PartnerStore>>;

}

/**
 * PartnerStoresApi - object-oriented interface
 * @export
 * @class PartnerStoresApi
 * @extends {BaseAPI}
 */
export class PartnerStoresApi extends BaseAPI implements PartnerStoresApiInterface {
    /**
     * API view to list all partner stores No authentication required Ordered by order field (ascending) then by creation date (LIFO - newest first)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerStoresApi
     */
    public partnerStoresList(options?: AxiosRequestConfig) {
        return PartnerStoresApiFp(this.configuration).partnerStoresList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check the status of a payment using the Stripe session ID
         * @summary Check payment status
         * @param {string} sessionId Stripe checkout session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCheckStatusRetrieve: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('paymentsCheckStatusRetrieve', 'sessionId', sessionId)
            const localVarPath = `/api/payments/check_status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Stripe checkout session for payment
         * @summary Create payment checkout session
         * @param {PaymentCheckoutSessionRequest} paymentCheckoutSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreateCheckoutSessionCreate: async (paymentCheckoutSessionRequest: PaymentCheckoutSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentCheckoutSessionRequest' is not null or undefined
            assertParamExists('paymentsCreateCheckoutSessionCreate', 'paymentCheckoutSessionRequest', paymentCheckoutSessionRequest)
            const localVarPath = `/api/payments/create_checkout_session/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCheckoutSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of payment transactions for the current user
         * @summary List user payment transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsTransactionsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/transactions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details for a specific payment transaction
         * @summary Get payment transaction details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsTransactionsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentsTransactionsRetrieve', 'id', id)
            const localVarPath = `/api/payments/transactions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check the status of a payment using the Stripe session ID
         * @summary Check payment status
         * @param {string} sessionId Stripe checkout session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCheckStatusRetrieve(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsCheckStatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCheckStatusRetrieve(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Stripe checkout session for payment
         * @summary Create payment checkout session
         * @param {PaymentCheckoutSessionRequest} paymentCheckoutSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest: PaymentCheckoutSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersPayCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of payment transactions for the current user
         * @summary List user payment transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsTransactionsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsTransactionsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details for a specific payment transaction
         * @summary Get payment transaction details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentsTransactionsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentsTransactionsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Check the status of a payment using the Stripe session ID
         * @summary Check payment status
         * @param {string} sessionId Stripe checkout session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCheckStatusRetrieve(sessionId: string, options?: any): AxiosPromise<PaymentsCheckStatusRetrieve200Response> {
            return localVarFp.paymentsCheckStatusRetrieve(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Stripe checkout session for payment
         * @summary Create payment checkout session
         * @param {PaymentCheckoutSessionRequest} paymentCheckoutSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest: PaymentCheckoutSessionRequest, options?: any): AxiosPromise<OrdersPayCreate200Response> {
            return localVarFp.paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of payment transactions for the current user
         * @summary List user payment transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsTransactionsList(options?: any): AxiosPromise<Array<PaymentTransaction>> {
            return localVarFp.paymentsTransactionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details for a specific payment transaction
         * @summary Get payment transaction details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsTransactionsRetrieve(id: string, options?: any): AxiosPromise<PaymentTransaction> {
            return localVarFp.paymentsTransactionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - interface
 * @export
 * @interface PaymentsApi
 */
export interface PaymentsApiInterface {
    /**
     * Check the status of a payment using the Stripe session ID
     * @summary Check payment status
     * @param {string} sessionId Stripe checkout session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    paymentsCheckStatusRetrieve(sessionId: string, options?: AxiosRequestConfig): AxiosPromise<PaymentsCheckStatusRetrieve200Response>;

    /**
     * Create a Stripe checkout session for payment
     * @summary Create payment checkout session
     * @param {PaymentCheckoutSessionRequest} paymentCheckoutSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest: PaymentCheckoutSessionRequest, options?: AxiosRequestConfig): AxiosPromise<OrdersPayCreate200Response>;

    /**
     * Returns a list of payment transactions for the current user
     * @summary List user payment transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    paymentsTransactionsList(options?: AxiosRequestConfig): AxiosPromise<Array<PaymentTransaction>>;

    /**
     * Retrieve details for a specific payment transaction
     * @summary Get payment transaction details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    paymentsTransactionsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<PaymentTransaction>;

}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI implements PaymentsApiInterface {
    /**
     * Check the status of a payment using the Stripe session ID
     * @summary Check payment status
     * @param {string} sessionId Stripe checkout session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsCheckStatusRetrieve(sessionId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCheckStatusRetrieve(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Stripe checkout session for payment
     * @summary Create payment checkout session
     * @param {PaymentCheckoutSessionRequest} paymentCheckoutSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest: PaymentCheckoutSessionRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsCreateCheckoutSessionCreate(paymentCheckoutSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of payment transactions for the current user
     * @summary List user payment transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsTransactionsList(options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsTransactionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details for a specific payment transaction
     * @summary Get payment transaction details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public paymentsTransactionsRetrieve(id: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).paymentsTransactionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RefLogsApi - axios parameter creator
 * @export
 */
export const RefLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Log when a user clicks on a referral link for a venue. If a similar log already exists for the same user, ref_code, and venue, it will skip creating a duplicate.
         * @summary Log referral click
         * @param {RefLogClickRequest} refLogClickRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logRefClick: async (refLogClickRequest: RefLogClickRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refLogClickRequest' is not null or undefined
            assertParamExists('logRefClick', 'refLogClickRequest', refLogClickRequest)
            const localVarPath = `/api/ref-logs/click/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refLogClickRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefLogsApi - functional programming interface
 * @export
 */
export const RefLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Log when a user clicks on a referral link for a venue. If a similar log already exists for the same user, ref_code, and venue, it will skip creating a duplicate.
         * @summary Log referral click
         * @param {RefLogClickRequest} refLogClickRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logRefClick(refLogClickRequest: RefLogClickRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logRefClick(refLogClickRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefLogsApi - factory interface
 * @export
 */
export const RefLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefLogsApiFp(configuration)
    return {
        /**
         * Log when a user clicks on a referral link for a venue. If a similar log already exists for the same user, ref_code, and venue, it will skip creating a duplicate.
         * @summary Log referral click
         * @param {RefLogClickRequest} refLogClickRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logRefClick(refLogClickRequest: RefLogClickRequest, options?: any): AxiosPromise<RefLogResponse> {
            return localVarFp.logRefClick(refLogClickRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefLogsApi - interface
 * @export
 * @interface RefLogsApi
 */
export interface RefLogsApiInterface {
    /**
     * Log when a user clicks on a referral link for a venue. If a similar log already exists for the same user, ref_code, and venue, it will skip creating a duplicate.
     * @summary Log referral click
     * @param {RefLogClickRequest} refLogClickRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefLogsApiInterface
     */
    logRefClick(refLogClickRequest: RefLogClickRequest, options?: AxiosRequestConfig): AxiosPromise<RefLogResponse>;

}

/**
 * RefLogsApi - object-oriented interface
 * @export
 * @class RefLogsApi
 * @extends {BaseAPI}
 */
export class RefLogsApi extends BaseAPI implements RefLogsApiInterface {
    /**
     * Log when a user clicks on a referral link for a venue. If a similar log already exists for the same user, ref_code, and venue, it will skip creating a duplicate.
     * @summary Log referral click
     * @param {RefLogClickRequest} refLogClickRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefLogsApi
     */
    public logRefClick(refLogClickRequest: RefLogClickRequest, options?: AxiosRequestConfig) {
        return RefLogsApiFp(this.configuration).logRefClick(refLogClickRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReservationsApi - axios parameter creator
 * @export
 */
export const ReservationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk update status for multiple reservations. Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
         * @summary Bulk update reservation status
         * @param {BulkReservationStatusRequest} bulkReservationStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsBulkStatusUpdate: async (bulkReservationStatusRequest: BulkReservationStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkReservationStatusRequest' is not null or undefined
            assertParamExists('reservationsBulkStatusUpdate', 'bulkReservationStatusRequest', bulkReservationStatusRequest)
            const localVarPath = `/api/reservations/bulk-status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkReservationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new reservation for a venue with optional venue questions
         * @summary Create reservation
         * @param {ReservationRequest} reservationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsCreate: async (reservationRequest: ReservationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationRequest' is not null or undefined
            assertParamExists('reservationsCreate', 'reservationRequest', reservationRequest)
            const localVarPath = `/api/reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a reservation (only for the reservation owner or venue manager)
         * @summary Cancel reservation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationsDestroy', 'id', id)
            const localVarPath = `/api/reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of reservations for the current user or reservations from venues the user manages
         * @summary List reservations
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsList: async (endDate?: string, page?: number, pageSize?: number, startDate?: string, status?: string, venue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve reservations by current user.
         * @summary List reservations by current user
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsMyReservationsList: async (endDate?: string, startDate?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reservations/my-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing reservations
         * @param {string} id 
         * @param {PatchedReservationRequest} [patchedReservationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsPartialUpdate: async (id: string, patchedReservationRequest?: PatchedReservationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationsPartialUpdate', 'id', id)
            const localVarPath = `/api/reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedReservationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a reservation
         * @summary Get reservation details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationsRetrieve', 'id', id)
            const localVarPath = `/api/reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for viewing reservation status history.
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsStatusHistoryList: async (reservationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('reservationsStatusHistoryList', 'reservationId', reservationId)
            const localVarPath = `/api/reservations/{reservation_id}/status-history/`
                .replace(`{${"reservation_id"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a reservation (venue managers only)
         * @summary Update reservation status
         * @param {string} id 
         * @param {ReservationStatusUpdateRequest} [reservationStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsStatusUpdate: async (id: string, reservationStatusUpdateRequest?: ReservationStatusUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationsStatusUpdate', 'id', id)
            const localVarPath = `/api/reservations/{id}/status/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationStatusUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update reservation details (only for the reservation owner)
         * @summary Update reservation
         * @param {string} id 
         * @param {ReservationRequest} reservationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsUpdate: async (id: string, reservationRequest: ReservationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationsUpdate', 'id', id)
            // verify required parameter 'reservationRequest' is not null or undefined
            assertParamExists('reservationsUpdate', 'reservationRequest', reservationRequest)
            const localVarPath = `/api/reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationsApi - functional programming interface
 * @export
 */
export const ReservationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk update status for multiple reservations. Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
         * @summary Bulk update reservation status
         * @param {BulkReservationStatusRequest} bulkReservationStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsBulkStatusUpdate(bulkReservationStatusRequest: BulkReservationStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsBulkStatusUpdate(bulkReservationStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new reservation for a venue with optional venue questions
         * @summary Create reservation
         * @param {ReservationRequest} reservationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsCreate(reservationRequest: ReservationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsCreate(reservationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a reservation (only for the reservation owner or venue manager)
         * @summary Cancel reservation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of reservations for the current user or reservations from venues the user manages
         * @summary List reservations
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsList(endDate?: string, page?: number, pageSize?: number, startDate?: string, status?: string, venue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReservationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsList(endDate, page, pageSize, startDate, status, venue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve reservations by current user.
         * @summary List reservations by current user
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsMyReservationsList(endDate?: string, startDate?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reservation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsMyReservationsList(endDate, startDate, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing reservations
         * @param {string} id 
         * @param {PatchedReservationRequest} [patchedReservationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsPartialUpdate(id: string, patchedReservationRequest?: PatchedReservationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsPartialUpdate(id, patchedReservationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about a reservation
         * @summary Get reservation details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for viewing reservation status history.
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsStatusHistoryList(reservationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReservationStatusHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsStatusHistoryList(reservationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the status of a reservation (venue managers only)
         * @summary Update reservation status
         * @param {string} id 
         * @param {ReservationStatusUpdateRequest} [reservationStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsStatusUpdate(id: string, reservationStatusUpdateRequest?: ReservationStatusUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationStatusUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsStatusUpdate(id, reservationStatusUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update reservation details (only for the reservation owner)
         * @summary Update reservation
         * @param {string} id 
         * @param {ReservationRequest} reservationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationsUpdate(id: string, reservationRequest: ReservationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationsUpdate(id, reservationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReservationsApi - factory interface
 * @export
 */
export const ReservationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationsApiFp(configuration)
    return {
        /**
         * Bulk update status for multiple reservations. Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
         * @summary Bulk update reservation status
         * @param {BulkReservationStatusRequest} bulkReservationStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsBulkStatusUpdate(bulkReservationStatusRequest: BulkReservationStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.reservationsBulkStatusUpdate(bulkReservationStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new reservation for a venue with optional venue questions
         * @summary Create reservation
         * @param {ReservationRequest} reservationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsCreate(reservationRequest: ReservationRequest, options?: any): AxiosPromise<Reservation> {
            return localVarFp.reservationsCreate(reservationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a reservation (only for the reservation owner or venue manager)
         * @summary Cancel reservation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.reservationsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of reservations for the current user or reservations from venues the user manages
         * @summary List reservations
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {number} [page] Page number
         * @param {number} [pageSize] Number of results per page (max 100)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
         * @param {string} [venue] Filter by venue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsList(endDate?: string, page?: number, pageSize?: number, startDate?: string, status?: string, venue?: string, options?: any): AxiosPromise<PaginatedReservationList> {
            return localVarFp.reservationsList(endDate, page, pageSize, startDate, status, venue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve reservations by current user.
         * @summary List reservations by current user
         * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
         * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
         * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsMyReservationsList(endDate?: string, startDate?: string, status?: string, options?: any): AxiosPromise<Array<Reservation>> {
            return localVarFp.reservationsMyReservationsList(endDate, startDate, status, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing reservations
         * @param {string} id 
         * @param {PatchedReservationRequest} [patchedReservationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsPartialUpdate(id: string, patchedReservationRequest?: PatchedReservationRequest, options?: any): AxiosPromise<Reservation> {
            return localVarFp.reservationsPartialUpdate(id, patchedReservationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a reservation
         * @summary Get reservation details
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsRetrieve(id: string, options?: any): AxiosPromise<Reservation> {
            return localVarFp.reservationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for viewing reservation status history.
         * @param {string} reservationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsStatusHistoryList(reservationId: string, options?: any): AxiosPromise<Array<ReservationStatusHistory>> {
            return localVarFp.reservationsStatusHistoryList(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a reservation (venue managers only)
         * @summary Update reservation status
         * @param {string} id 
         * @param {ReservationStatusUpdateRequest} [reservationStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsStatusUpdate(id: string, reservationStatusUpdateRequest?: ReservationStatusUpdateRequest, options?: any): AxiosPromise<ReservationStatusUpdate> {
            return localVarFp.reservationsStatusUpdate(id, reservationStatusUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update reservation details (only for the reservation owner)
         * @summary Update reservation
         * @param {string} id 
         * @param {ReservationRequest} reservationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationsUpdate(id: string, reservationRequest: ReservationRequest, options?: any): AxiosPromise<Reservation> {
            return localVarFp.reservationsUpdate(id, reservationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReservationsApi - interface
 * @export
 * @interface ReservationsApi
 */
export interface ReservationsApiInterface {
    /**
     * Bulk update status for multiple reservations. Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
     * @summary Bulk update reservation status
     * @param {BulkReservationStatusRequest} bulkReservationStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsBulkStatusUpdate(bulkReservationStatusRequest: BulkReservationStatusRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Create a new reservation for a venue with optional venue questions
     * @summary Create reservation
     * @param {ReservationRequest} reservationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsCreate(reservationRequest: ReservationRequest, options?: AxiosRequestConfig): AxiosPromise<Reservation>;

    /**
     * Cancel a reservation (only for the reservation owner or venue manager)
     * @summary Cancel reservation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of reservations for the current user or reservations from venues the user manages
     * @summary List reservations
     * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of results per page (max 100)
     * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
     * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsList(endDate?: string, page?: number, pageSize?: number, startDate?: string, status?: string, venue?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedReservationList>;

    /**
     * Retrieve reservations by current user.
     * @summary List reservations by current user
     * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
     * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
     * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsMyReservationsList(endDate?: string, startDate?: string, status?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Reservation>>;

    /**
     * API endpoints for managing reservations
     * @param {string} id 
     * @param {PatchedReservationRequest} [patchedReservationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsPartialUpdate(id: string, patchedReservationRequest?: PatchedReservationRequest, options?: AxiosRequestConfig): AxiosPromise<Reservation>;

    /**
     * Get detailed information about a reservation
     * @summary Get reservation details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Reservation>;

    /**
     * API endpoints for viewing reservation status history.
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsStatusHistoryList(reservationId: string, options?: AxiosRequestConfig): AxiosPromise<Array<ReservationStatusHistory>>;

    /**
     * Update the status of a reservation (venue managers only)
     * @summary Update reservation status
     * @param {string} id 
     * @param {ReservationStatusUpdateRequest} [reservationStatusUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsStatusUpdate(id: string, reservationStatusUpdateRequest?: ReservationStatusUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<ReservationStatusUpdate>;

    /**
     * Update reservation details (only for the reservation owner)
     * @summary Update reservation
     * @param {string} id 
     * @param {ReservationRequest} reservationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApiInterface
     */
    reservationsUpdate(id: string, reservationRequest: ReservationRequest, options?: AxiosRequestConfig): AxiosPromise<Reservation>;

}

/**
 * ReservationsApi - object-oriented interface
 * @export
 * @class ReservationsApi
 * @extends {BaseAPI}
 */
export class ReservationsApi extends BaseAPI implements ReservationsApiInterface {
    /**
     * Bulk update status for multiple reservations. Status must follow flow: PENDING  CONFIRMED  PREPARING  READY  COMPLETED
     * @summary Bulk update reservation status
     * @param {BulkReservationStatusRequest} bulkReservationStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsBulkStatusUpdate(bulkReservationStatusRequest: BulkReservationStatusRequest, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsBulkStatusUpdate(bulkReservationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new reservation for a venue with optional venue questions
     * @summary Create reservation
     * @param {ReservationRequest} reservationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsCreate(reservationRequest: ReservationRequest, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsCreate(reservationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a reservation (only for the reservation owner or venue manager)
     * @summary Cancel reservation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsDestroy(id: string, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of reservations for the current user or reservations from venues the user manages
     * @summary List reservations
     * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
     * @param {number} [page] Page number
     * @param {number} [pageSize] Number of results per page (max 100)
     * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
     * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
     * @param {string} [venue] Filter by venue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsList(endDate?: string, page?: number, pageSize?: number, startDate?: string, status?: string, venue?: string, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsList(endDate, page, pageSize, startDate, status, venue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve reservations by current user.
     * @summary List reservations by current user
     * @param {string} [endDate] Filter by end date (YYYY-MM-DD)
     * @param {string} [startDate] Filter by start date (YYYY-MM-DD)
     * @param {string} [status] Filter by status (comma-separated for multiple, e.g. \&#39;PENDING,CONFIRMED\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsMyReservationsList(endDate?: string, startDate?: string, status?: string, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsMyReservationsList(endDate, startDate, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing reservations
     * @param {string} id 
     * @param {PatchedReservationRequest} [patchedReservationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsPartialUpdate(id: string, patchedReservationRequest?: PatchedReservationRequest, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsPartialUpdate(id, patchedReservationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a reservation
     * @summary Get reservation details
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsRetrieve(id: string, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for viewing reservation status history.
     * @param {string} reservationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsStatusHistoryList(reservationId: string, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsStatusHistoryList(reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a reservation (venue managers only)
     * @summary Update reservation status
     * @param {string} id 
     * @param {ReservationStatusUpdateRequest} [reservationStatusUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsStatusUpdate(id: string, reservationStatusUpdateRequest?: ReservationStatusUpdateRequest, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsStatusUpdate(id, reservationStatusUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update reservation details (only for the reservation owner)
     * @summary Update reservation
     * @param {string} id 
     * @param {ReservationRequest} reservationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationsApi
     */
    public reservationsUpdate(id: string, reservationRequest: ReservationRequest, options?: AxiosRequestConfig) {
        return ReservationsApiFp(this.configuration).reservationsUpdate(id, reservationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StockedVenuesApi - axios parameter creator
 * @export
 */
export const StockedVenuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Save a venue to the user\'s stocked venues list
         * @summary Add venue to stocked venues
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesCreate: async (stockedVenueRequest: StockedVenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockedVenueRequest' is not null or undefined
            assertParamExists('stockedVenuesCreate', 'stockedVenueRequest', stockedVenueRequest)
            const localVarPath = `/api/stocked-venues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockedVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a venue from the user\'s stocked venues list
         * @summary Remove venue from stocked venues
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stockedVenuesDestroy', 'id', id)
            const localVarPath = `/api/stocked-venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the favorite status of a stocked venue
         * @summary Toggle favorite status
         * @param {string} id 
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesFavoriteUpdate: async (id: string, stockedVenueRequest: StockedVenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stockedVenuesFavoriteUpdate', 'id', id)
            // verify required parameter 'stockedVenueRequest' is not null or undefined
            assertParamExists('stockedVenuesFavoriteUpdate', 'stockedVenueRequest', stockedVenueRequest)
            const localVarPath = `/api/stocked-venues/{id}/favorite/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockedVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of venues saved by the current user
         * @summary List user\'s stocked venues
         * @param {string} [genre] Filter by genre
         * @param {boolean} [isFavorite] Filter by favorite status
         * @param {string} [nearestStation] Filter by nearest station
         * @param {StockedVenuesListOrderTypesEnum} [orderTypes] Filter timeslots by order type (DINE_IN or TAKEOUT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesList: async (genre?: string, isFavorite?: boolean, nearestStation?: string, orderTypes?: StockedVenuesListOrderTypesEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stocked-venues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['is_favorite'] = isFavorite;
            }

            if (nearestStation !== undefined) {
                localVarQueryParameter['nearest_station'] = nearestStation;
            }

            if (orderTypes !== undefined) {
                localVarQueryParameter['order_types'] = orderTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {PatchedStockedVenueRequest} [patchedStockedVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesPartialUpdate: async (id: string, patchedStockedVenueRequest?: PatchedStockedVenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stockedVenuesPartialUpdate', 'id', id)
            const localVarPath = `/api/stocked-venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStockedVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stockedVenuesRetrieve', 'id', id)
            const localVarPath = `/api/stocked-venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesUpdate: async (id: string, stockedVenueRequest: StockedVenueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stockedVenuesUpdate', 'id', id)
            // verify required parameter 'stockedVenueRequest' is not null or undefined
            assertParamExists('stockedVenuesUpdate', 'stockedVenueRequest', stockedVenueRequest)
            const localVarPath = `/api/stocked-venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockedVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockedVenuesApi - functional programming interface
 * @export
 */
export const StockedVenuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockedVenuesApiAxiosParamCreator(configuration)
    return {
        /**
         * Save a venue to the user\'s stocked venues list
         * @summary Add venue to stocked venues
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesCreate(stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockedVenue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesCreate(stockedVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a venue from the user\'s stocked venues list
         * @summary Remove venue from stocked venues
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Toggle the favorite status of a stocked venue
         * @summary Toggle favorite status
         * @param {string} id 
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesFavoriteUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesFavoriteUpdate(id, stockedVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of venues saved by the current user
         * @summary List user\'s stocked venues
         * @param {string} [genre] Filter by genre
         * @param {boolean} [isFavorite] Filter by favorite status
         * @param {string} [nearestStation] Filter by nearest station
         * @param {StockedVenuesListOrderTypesEnum} [orderTypes] Filter timeslots by order type (DINE_IN or TAKEOUT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesList(genre?: string, isFavorite?: boolean, nearestStation?: string, orderTypes?: StockedVenuesListOrderTypesEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockedVenue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesList(genre, isFavorite, nearestStation, orderTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {PatchedStockedVenueRequest} [patchedStockedVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesPartialUpdate(id: string, patchedStockedVenueRequest?: PatchedStockedVenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockedVenue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesPartialUpdate(id, patchedStockedVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockedVenue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockedVenuesUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockedVenue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockedVenuesUpdate(id, stockedVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockedVenuesApi - factory interface
 * @export
 */
export const StockedVenuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockedVenuesApiFp(configuration)
    return {
        /**
         * Save a venue to the user\'s stocked venues list
         * @summary Add venue to stocked venues
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesCreate(stockedVenueRequest: StockedVenueRequest, options?: any): AxiosPromise<StockedVenue> {
            return localVarFp.stockedVenuesCreate(stockedVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a venue from the user\'s stocked venues list
         * @summary Remove venue from stocked venues
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.stockedVenuesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle the favorite status of a stocked venue
         * @summary Toggle favorite status
         * @param {string} id 
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesFavoriteUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stockedVenuesFavoriteUpdate(id, stockedVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of venues saved by the current user
         * @summary List user\'s stocked venues
         * @param {string} [genre] Filter by genre
         * @param {boolean} [isFavorite] Filter by favorite status
         * @param {string} [nearestStation] Filter by nearest station
         * @param {StockedVenuesListOrderTypesEnum} [orderTypes] Filter timeslots by order type (DINE_IN or TAKEOUT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesList(genre?: string, isFavorite?: boolean, nearestStation?: string, orderTypes?: StockedVenuesListOrderTypesEnum, options?: any): AxiosPromise<Array<StockedVenue>> {
            return localVarFp.stockedVenuesList(genre, isFavorite, nearestStation, orderTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {PatchedStockedVenueRequest} [patchedStockedVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesPartialUpdate(id: string, patchedStockedVenueRequest?: PatchedStockedVenueRequest, options?: any): AxiosPromise<StockedVenue> {
            return localVarFp.stockedVenuesPartialUpdate(id, patchedStockedVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesRetrieve(id: string, options?: any): AxiosPromise<StockedVenue> {
            return localVarFp.stockedVenuesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing user\'s stocked venues
         * @param {string} id 
         * @param {StockedVenueRequest} stockedVenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockedVenuesUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: any): AxiosPromise<StockedVenue> {
            return localVarFp.stockedVenuesUpdate(id, stockedVenueRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockedVenuesApi - interface
 * @export
 * @interface StockedVenuesApi
 */
export interface StockedVenuesApiInterface {
    /**
     * Save a venue to the user\'s stocked venues list
     * @summary Add venue to stocked venues
     * @param {StockedVenueRequest} stockedVenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesCreate(stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig): AxiosPromise<StockedVenue>;

    /**
     * Remove a venue from the user\'s stocked venues list
     * @summary Remove venue from stocked venues
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Toggle the favorite status of a stocked venue
     * @summary Toggle favorite status
     * @param {string} id 
     * @param {StockedVenueRequest} stockedVenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesFavoriteUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of venues saved by the current user
     * @summary List user\'s stocked venues
     * @param {string} [genre] Filter by genre
     * @param {boolean} [isFavorite] Filter by favorite status
     * @param {string} [nearestStation] Filter by nearest station
     * @param {StockedVenuesListOrderTypesEnum} [orderTypes] Filter timeslots by order type (DINE_IN or TAKEOUT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesList(genre?: string, isFavorite?: boolean, nearestStation?: string, orderTypes?: StockedVenuesListOrderTypesEnum, options?: AxiosRequestConfig): AxiosPromise<Array<StockedVenue>>;

    /**
     * API endpoints for managing user\'s stocked venues
     * @param {string} id 
     * @param {PatchedStockedVenueRequest} [patchedStockedVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesPartialUpdate(id: string, patchedStockedVenueRequest?: PatchedStockedVenueRequest, options?: AxiosRequestConfig): AxiosPromise<StockedVenue>;

    /**
     * API endpoints for managing user\'s stocked venues
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<StockedVenue>;

    /**
     * API endpoints for managing user\'s stocked venues
     * @param {string} id 
     * @param {StockedVenueRequest} stockedVenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApiInterface
     */
    stockedVenuesUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig): AxiosPromise<StockedVenue>;

}

/**
 * StockedVenuesApi - object-oriented interface
 * @export
 * @class StockedVenuesApi
 * @extends {BaseAPI}
 */
export class StockedVenuesApi extends BaseAPI implements StockedVenuesApiInterface {
    /**
     * Save a venue to the user\'s stocked venues list
     * @summary Add venue to stocked venues
     * @param {StockedVenueRequest} stockedVenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesCreate(stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesCreate(stockedVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a venue from the user\'s stocked venues list
     * @summary Remove venue from stocked venues
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesDestroy(id: string, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle the favorite status of a stocked venue
     * @summary Toggle favorite status
     * @param {string} id 
     * @param {StockedVenueRequest} stockedVenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesFavoriteUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesFavoriteUpdate(id, stockedVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of venues saved by the current user
     * @summary List user\'s stocked venues
     * @param {string} [genre] Filter by genre
     * @param {boolean} [isFavorite] Filter by favorite status
     * @param {string} [nearestStation] Filter by nearest station
     * @param {StockedVenuesListOrderTypesEnum} [orderTypes] Filter timeslots by order type (DINE_IN or TAKEOUT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesList(genre?: string, isFavorite?: boolean, nearestStation?: string, orderTypes?: StockedVenuesListOrderTypesEnum, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesList(genre, isFavorite, nearestStation, orderTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing user\'s stocked venues
     * @param {string} id 
     * @param {PatchedStockedVenueRequest} [patchedStockedVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesPartialUpdate(id: string, patchedStockedVenueRequest?: PatchedStockedVenueRequest, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesPartialUpdate(id, patchedStockedVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing user\'s stocked venues
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesRetrieve(id: string, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing user\'s stocked venues
     * @param {string} id 
     * @param {StockedVenueRequest} stockedVenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockedVenuesApi
     */
    public stockedVenuesUpdate(id: string, stockedVenueRequest: StockedVenueRequest, options?: AxiosRequestConfig) {
        return StockedVenuesApiFp(this.configuration).stockedVenuesUpdate(id, stockedVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StockedVenuesListOrderTypesEnum = {
    DineIn: 'DINE_IN',
    Takeout: 'TAKEOUT'
} as const;
export type StockedVenuesListOrderTypesEnum = typeof StockedVenuesListOrderTypesEnum[keyof typeof StockedVenuesListOrderTypesEnum];


/**
 * SystemSettingsApi - axios parameter creator
 * @export
 */
export const SystemSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current application fee amount and tax rate
         * @summary Get application fee information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemSettingsApplicationFeeRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/system-settings/application-fee/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemSettingsApi - functional programming interface
 * @export
 */
export const SystemSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current application fee amount and tax rate
         * @summary Get application fee information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemSettingsApplicationFeeRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationFee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemSettingsApplicationFeeRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemSettingsApi - factory interface
 * @export
 */
export const SystemSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemSettingsApiFp(configuration)
    return {
        /**
         * Returns the current application fee amount and tax rate
         * @summary Get application fee information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemSettingsApplicationFeeRetrieve(options?: any): AxiosPromise<ApplicationFee> {
            return localVarFp.systemSettingsApplicationFeeRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemSettingsApi - interface
 * @export
 * @interface SystemSettingsApi
 */
export interface SystemSettingsApiInterface {
    /**
     * Returns the current application fee amount and tax rate
     * @summary Get application fee information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemSettingsApiInterface
     */
    systemSettingsApplicationFeeRetrieve(options?: AxiosRequestConfig): AxiosPromise<ApplicationFee>;

}

/**
 * SystemSettingsApi - object-oriented interface
 * @export
 * @class SystemSettingsApi
 * @extends {BaseAPI}
 */
export class SystemSettingsApi extends BaseAPI implements SystemSettingsApiInterface {
    /**
     * Returns the current application fee amount and tax rate
     * @summary Get application fee information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemSettingsApi
     */
    public systemSettingsApplicationFeeRetrieve(options?: AxiosRequestConfig) {
        return SystemSettingsApiFp(this.configuration).systemSettingsApplicationFeeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VenuesApi - axios parameter creator
 * @export
 */
export const VenuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new venue (admin only). Use multipart/form-data when uploading venue logo or images.
         * @summary Create a new venue
         * @param {string} name 
         * @param {string} address 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesCreate: async (name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('venuesCreate', 'name', name)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('venuesCreate', 'address', address)
            const localVarPath = `/api/venues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (address !== undefined) { 
                localVarFormParams.append('address', address as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (announcement !== undefined) { 
                localVarFormParams.append('announcement', announcement as any);
            }
    
            if (phoneNumber !== undefined) { 
                localVarFormParams.append('phone_number', phoneNumber as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (website !== undefined) { 
                localVarFormParams.append('website', website as any);
            }
    
            if (openingTime !== undefined) { 
                localVarFormParams.append('opening_time', openingTime as any);
            }
    
            if (closingTime !== undefined) { 
                localVarFormParams.append('closing_time', closingTime as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('is_active', isActive as any);
            }
    
            if (enableReservation !== undefined) { 
                localVarFormParams.append('enable_reservation', enableReservation as any);
            }
    
            if (enableEatIn !== undefined) { 
                localVarFormParams.append('enable_eat_in', enableEatIn as any);
            }
    
            if (enableTakeOut !== undefined) { 
                localVarFormParams.append('enable_take_out', enableTakeOut as any);
            }
    
            if (enableOrderQuestions !== undefined) { 
                localVarFormParams.append('enable_order_questions', enableOrderQuestions as any);
            }
    
            if (logo !== undefined) { 
                localVarFormParams.append('logo', logo as any);
            }
    
            if (qrCode !== undefined) { 
                localVarFormParams.append('qr_code', qrCode as any);
            }
    
            if (enableCashPayment !== undefined) { 
                localVarFormParams.append('enable_cash_payment', enableCashPayment as any);
            }
    
            if (enableOnlinePayment !== undefined) { 
                localVarFormParams.append('enable_online_payment', enableOnlinePayment as any);
            }
    
            if (additionalInfo !== undefined) { 
                localVarFormParams.append('additional_info', additionalInfo as any);
            }
    
            if (additionalInfoEn !== undefined) { 
                localVarFormParams.append('additional_info_en', additionalInfoEn as any);
            }
    
            if (genre !== undefined) { 
                localVarFormParams.append('genre', genre as any);
            }
    
            if (genreEn !== undefined) { 
                localVarFormParams.append('genre_en', genreEn as any);
            }
    
            if (bufferTime !== undefined) { 
                localVarFormParams.append('buffer_time', bufferTime as any);
            }
    
            if (nearestStation !== undefined) { 
                localVarFormParams.append('nearest_station', nearestStation as any);
            }
    
            if (nearestStationEn !== undefined) { 
                localVarFormParams.append('nearest_station_en', nearestStationEn as any);
            }
    
            if (customPlatformFeeAmount !== undefined) { 
                localVarFormParams.append('custom_platform_fee_amount', customPlatformFeeAmount as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a venue (admin only)
         * @summary Delete venue
         * @param {string} id A UUID string identifying this venue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesDestroy', 'id', id)
            const localVarPath = `/api/venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all venues with basic information, ordered by creation date (newest first)
         * @summary List all venues
         * @param {string} [genre] Filter by genre
         * @param {VenuesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {string} [name] Filter by venue name
         * @param {string} [nearestStation] Filter by nearest station
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesList: async (genre?: string, multilingual?: VenuesListMultilingualEnum, name?: string, nearestStation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/venues/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nearestStation !== undefined) {
                localVarQueryParameter['nearest_station'] = nearestStation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the complete menu for a venue, including all categories and items
         * @summary Get venue menu
         * @param {string} id A UUID string identifying this venue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenuRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenuRetrieve', 'id', id)
            const localVarPath = `/api/venues/{id}/menu/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new menu category for a venue (venue managers or admins only)
         * @summary Create menu category
         * @param {string} venueId 
         * @param {MenuCategoryRequest} menuCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesCreate: async (venueId: string, menuCategoryRequest: MenuCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesCreate', 'venueId', venueId)
            // verify required parameter 'menuCategoryRequest' is not null or undefined
            assertParamExists('venuesMenusCategoriesCreate', 'menuCategoryRequest', menuCategoryRequest)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menuCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a menu category (venue managers or admins only)
         * @summary Delete menu category
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesDestroy: async (id: string, venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusCategoriesDestroy', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesDestroy', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of menu categories for a venue
         * @summary List menu categories
         * @param {string} venueId 
         * @param {VenuesMenusCategoriesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesList: async (venueId: string, multilingual?: VenuesMenusCategoriesListMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesList', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all menu categories with their associated menu items
         * @summary List categories with items
         * @param {string} venueId 
         * @param {VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesListWithItemsRetrieve: async (venueId: string, multilingual?: VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesListWithItemsRetrieve', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/list_with_items/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing menu categories
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {PatchedMenuCategoryRequest} [patchedMenuCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesPartialUpdate: async (id: string, venueId: string, patchedMenuCategoryRequest?: PatchedMenuCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusCategoriesPartialUpdate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesPartialUpdate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMenuCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a menu category
         * @summary Get menu category details
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesRetrieve: async (id: string, venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusCategoriesRetrieve', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesRetrieve', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a menu category (venue managers or admins only)
         * @summary Update menu category
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {MenuCategoryRequest} menuCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesUpdate: async (id: string, venueId: string, menuCategoryRequest: MenuCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusCategoriesUpdate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusCategoriesUpdate', 'venueId', venueId)
            // verify required parameter 'menuCategoryRequest' is not null or undefined
            assertParamExists('venuesMenusCategoriesUpdate', 'menuCategoryRequest', menuCategoryRequest)
            const localVarPath = `/api/venues/{venue_id}/menus/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menuCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing menu items
         * @param {string} venueId 
         * @param {MenuItemStockUpdateRequest} menuItemStockUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsBulkUpdateStockCreate: async (venueId: string, menuItemStockUpdateRequest: MenuItemStockUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsBulkUpdateStockCreate', 'venueId', venueId)
            // verify required parameter 'menuItemStockUpdateRequest' is not null or undefined
            assertParamExists('venuesMenusItemsBulkUpdateStockCreate', 'menuItemStockUpdateRequest', menuItemStockUpdateRequest)
            const localVarPath = `/api/venues/{venue_id}/menus/items/bulk-update-stock/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menuItemStockUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new menu item for a venue (venue managers or admins only). Use multipart/form-data when uploading menu item images.
         * @summary Create menu item
         * @param {string} venueId 
         * @param {string} name 
         * @param {string} price 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsCreate: async (venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsCreate', 'venueId', venueId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('venuesMenusItemsCreate', 'name', name)
            // verify required parameter 'price' is not null or undefined
            assertParamExists('venuesMenusItemsCreate', 'price', price)
            const localVarPath = `/api/venues/{venue_id}/menus/items/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (takeOutPrice !== undefined) { 
                localVarFormParams.append('take_out_price', takeOutPrice as any);
            }
    
            if (isAvailable !== undefined) { 
                localVarFormParams.append('is_available', isAvailable as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (ingredients !== undefined) { 
                localVarFormParams.append('ingredients', ingredients as any);
            }
    
            if (preparationTime !== undefined) { 
                localVarFormParams.append('preparation_time', preparationTime as any);
            }
    
            if (isAlcoholic !== undefined) { 
                localVarFormParams.append('is_alcoholic', isAlcoholic as any);
            }
    
            if (isPriorityPass !== undefined) { 
                localVarFormParams.append('is_priority_pass', isPriorityPass as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a menu item (venue managers or admins only)
         * @summary Delete menu item
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsDestroy: async (id: string, venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusItemsDestroy', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsDestroy', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of menu items for a venue
         * @summary List menu items
         * @param {string} venueId 
         * @param {string} [category] Filter by category ID
         * @param {boolean} [isAvailable] Filter by availability
         * @param {VenuesMenusItemsListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsList: async (venueId: string, category?: string, isAvailable?: boolean, multilingual?: VenuesMenusItemsListMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsList', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/items/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isAvailable !== undefined) {
                localVarQueryParameter['is_available'] = isAvailable;
            }

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing menu items
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsPartialUpdate: async (id: string, venueId: string, name?: string, price?: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusItemsPartialUpdate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsPartialUpdate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (takeOutPrice !== undefined) { 
                localVarFormParams.append('take_out_price', takeOutPrice as any);
            }
    
            if (isAvailable !== undefined) { 
                localVarFormParams.append('is_available', isAvailable as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (ingredients !== undefined) { 
                localVarFormParams.append('ingredients', ingredients as any);
            }
    
            if (preparationTime !== undefined) { 
                localVarFormParams.append('preparation_time', preparationTime as any);
            }
    
            if (isAlcoholic !== undefined) { 
                localVarFormParams.append('is_alcoholic', isAlcoholic as any);
            }
    
            if (isPriorityPass !== undefined) { 
                localVarFormParams.append('is_priority_pass', isPriorityPass as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a menu item
         * @summary Get menu item details
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {VenuesMenusItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsRetrieve: async (id: string, venueId: string, multilingual?: VenuesMenusItemsRetrieveMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusItemsRetrieve', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsRetrieve', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/menus/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a menu item (venue managers or admins only). Use multipart/form-data when uploading menu item images.
         * @summary Update menu item
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {string} name 
         * @param {string} price 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsUpdate: async (id: string, venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesMenusItemsUpdate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesMenusItemsUpdate', 'venueId', venueId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('venuesMenusItemsUpdate', 'name', name)
            // verify required parameter 'price' is not null or undefined
            assertParamExists('venuesMenusItemsUpdate', 'price', price)
            const localVarPath = `/api/venues/{venue_id}/menus/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (takeOutPrice !== undefined) { 
                localVarFormParams.append('take_out_price', takeOutPrice as any);
            }
    
            if (isAvailable !== undefined) { 
                localVarFormParams.append('is_available', isAvailable as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (ingredients !== undefined) { 
                localVarFormParams.append('ingredients', ingredients as any);
            }
    
            if (preparationTime !== undefined) { 
                localVarFormParams.append('preparation_time', preparationTime as any);
            }
    
            if (isAlcoholic !== undefined) { 
                localVarFormParams.append('is_alcoholic', isAlcoholic as any);
            }
    
            if (isPriorityPass !== undefined) { 
                localVarFormParams.append('is_priority_pass', isPriorityPass as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoints for managing venues
         * @param {string} id A UUID string identifying this venue.
         * @param {string} [name] 
         * @param {string} [address] 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesPartialUpdate: async (id: string, name?: string, address?: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesPartialUpdate', 'id', id)
            const localVarPath = `/api/venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (address !== undefined) { 
                localVarFormParams.append('address', address as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (announcement !== undefined) { 
                localVarFormParams.append('announcement', announcement as any);
            }
    
            if (phoneNumber !== undefined) { 
                localVarFormParams.append('phone_number', phoneNumber as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (website !== undefined) { 
                localVarFormParams.append('website', website as any);
            }
    
            if (openingTime !== undefined) { 
                localVarFormParams.append('opening_time', openingTime as any);
            }
    
            if (closingTime !== undefined) { 
                localVarFormParams.append('closing_time', closingTime as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('is_active', isActive as any);
            }
    
            if (enableReservation !== undefined) { 
                localVarFormParams.append('enable_reservation', enableReservation as any);
            }
    
            if (enableEatIn !== undefined) { 
                localVarFormParams.append('enable_eat_in', enableEatIn as any);
            }
    
            if (enableTakeOut !== undefined) { 
                localVarFormParams.append('enable_take_out', enableTakeOut as any);
            }
    
            if (enableOrderQuestions !== undefined) { 
                localVarFormParams.append('enable_order_questions', enableOrderQuestions as any);
            }
    
            if (logo !== undefined) { 
                localVarFormParams.append('logo', logo as any);
            }
    
            if (qrCode !== undefined) { 
                localVarFormParams.append('qr_code', qrCode as any);
            }
    
            if (enableCashPayment !== undefined) { 
                localVarFormParams.append('enable_cash_payment', enableCashPayment as any);
            }
    
            if (enableOnlinePayment !== undefined) { 
                localVarFormParams.append('enable_online_payment', enableOnlinePayment as any);
            }
    
            if (additionalInfo !== undefined) { 
                localVarFormParams.append('additional_info', additionalInfo as any);
            }
    
            if (additionalInfoEn !== undefined) { 
                localVarFormParams.append('additional_info_en', additionalInfoEn as any);
            }
    
            if (genre !== undefined) { 
                localVarFormParams.append('genre', genre as any);
            }
    
            if (genreEn !== undefined) { 
                localVarFormParams.append('genre_en', genreEn as any);
            }
    
            if (bufferTime !== undefined) { 
                localVarFormParams.append('buffer_time', bufferTime as any);
            }
    
            if (nearestStation !== undefined) { 
                localVarFormParams.append('nearest_station', nearestStation as any);
            }
    
            if (nearestStationEn !== undefined) { 
                localVarFormParams.append('nearest_station_en', nearestStationEn as any);
            }
    
            if (customPlatformFeeAmount !== undefined) { 
                localVarFormParams.append('custom_platform_fee_amount', customPlatformFeeAmount as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get venue order questions configuration including enable flag and questions list
         * @summary Get venue questions configuration
         * @param {string} venueId 
         * @param {VenuesQuestionsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesQuestionsRetrieve: async (venueId: string, multilingual?: VenuesQuestionsRetrieveMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesQuestionsRetrieve', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/questions/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update venue order questions configuration including enable flag and questions list
         * @summary Update venue questions configuration
         * @param {string} venueId 
         * @param {VenueQuestionsUpdateRequest} [venueQuestionsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesQuestionsUpdate: async (venueId: string, venueQuestionsUpdateRequest?: VenueQuestionsUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesQuestionsUpdate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/questions/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(venueQuestionsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a venue by ID
         * @summary Get venue details
         * @param {string} id A UUID string identifying this venue.
         * @param {VenuesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesRetrieve: async (id: string, multilingual?: VenuesRetrieveMultilingualEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesRetrieve', 'id', id)
            const localVarPath = `/api/venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (multilingual !== undefined) {
                localVarQueryParameter['multilingual'] = multilingual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Stripe Connect account for a venue
         * @summary Create Stripe Connect account
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesStripeConnectCreate: async (venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesStripeConnectCreate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/stripe-connect/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Stripe Connect onboarding link for a venue
         * @summary Create onboarding link
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesStripeConnectOnboardingLinkCreate: async (venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesStripeConnectOnboardingLinkCreate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/stripe-connect/onboarding-link/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a venue\'s Stripe Connect account
         * @summary Get Stripe Connect account status
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesStripeConnectRetrieve: async (venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesStripeConnectRetrieve', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/stripe-connect/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a temporary additional limit to a time slot daily limit.
         * @param {string} id 
         * @param {string} venueId 
         * @param {TimeSlotDailyLimitRequest} [timeSlotDailyLimitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsAdditionalLimitCreate: async (id: string, venueId: string, timeSlotDailyLimitRequest?: TimeSlotDailyLimitRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesTimeSlotsAdditionalLimitCreate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsAdditionalLimitCreate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/time-slots/{id}/additional-limit/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSlotDailyLimitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} venueId 
         * @param {TimeSlotRequest} timeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsCreate: async (venueId: string, timeSlotRequest: TimeSlotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsCreate', 'venueId', venueId)
            // verify required parameter 'timeSlotRequest' is not null or undefined
            assertParamExists('venuesTimeSlotsCreate', 'timeSlotRequest', timeSlotRequest)
            const localVarPath = `/api/venues/{venue_id}/time-slots/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSlotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsDestroy: async (id: string, venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesTimeSlotsDestroy', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsDestroy', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/time-slots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of time slots filtered by service type.
         * @summary List time slots
         * @param {VenuesTimeSlotsListServiceTypeEnum} serviceType Filter by service type (DINE_IN or TAKEOUT)
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsList: async (serviceType: VenuesTimeSlotsListServiceTypeEnum, venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('venuesTimeSlotsList', 'serviceType', serviceType)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsList', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/time-slots/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serviceType !== undefined) {
                localVarQueryParameter['service_type'] = serviceType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {PatchedTimeSlotRequest} [patchedTimeSlotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsPartialUpdate: async (id: string, venueId: string, patchedTimeSlotRequest?: PatchedTimeSlotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesTimeSlotsPartialUpdate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsPartialUpdate', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/time-slots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTimeSlotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pause a time slot by setting.
         * @param {string} venueId 
         * @param {PausedTimeSlotRequest} pausedTimeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsPausedTimeSlotsCreate: async (venueId: string, pausedTimeSlotRequest: PausedTimeSlotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsPausedTimeSlotsCreate', 'venueId', venueId)
            // verify required parameter 'pausedTimeSlotRequest' is not null or undefined
            assertParamExists('venuesTimeSlotsPausedTimeSlotsCreate', 'pausedTimeSlotRequest', pausedTimeSlotRequest)
            const localVarPath = `/api/venues/{venue_id}/time-slots/paused-time-slots/`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pausedTimeSlotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsRetrieve: async (id: string, venueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesTimeSlotsRetrieve', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsRetrieve', 'venueId', venueId)
            const localVarPath = `/api/venues/{venue_id}/time-slots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {TimeSlotRequest} timeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsUpdate: async (id: string, venueId: string, timeSlotRequest: TimeSlotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesTimeSlotsUpdate', 'id', id)
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('venuesTimeSlotsUpdate', 'venueId', venueId)
            // verify required parameter 'timeSlotRequest' is not null or undefined
            assertParamExists('venuesTimeSlotsUpdate', 'timeSlotRequest', timeSlotRequest)
            const localVarPath = `/api/venues/{venue_id}/time-slots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSlotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update venue information (venue managers or admins only). Use multipart/form-data when uploading venue logo or images.
         * @summary Update venue
         * @param {string} id A UUID string identifying this venue.
         * @param {string} name 
         * @param {string} address 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesUpdate: async (id: string, name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('venuesUpdate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('venuesUpdate', 'name', name)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('venuesUpdate', 'address', address)
            const localVarPath = `/api/venues/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (address !== undefined) { 
                localVarFormParams.append('address', address as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (announcement !== undefined) { 
                localVarFormParams.append('announcement', announcement as any);
            }
    
            if (phoneNumber !== undefined) { 
                localVarFormParams.append('phone_number', phoneNumber as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (website !== undefined) { 
                localVarFormParams.append('website', website as any);
            }
    
            if (openingTime !== undefined) { 
                localVarFormParams.append('opening_time', openingTime as any);
            }
    
            if (closingTime !== undefined) { 
                localVarFormParams.append('closing_time', closingTime as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('is_active', isActive as any);
            }
    
            if (enableReservation !== undefined) { 
                localVarFormParams.append('enable_reservation', enableReservation as any);
            }
    
            if (enableEatIn !== undefined) { 
                localVarFormParams.append('enable_eat_in', enableEatIn as any);
            }
    
            if (enableTakeOut !== undefined) { 
                localVarFormParams.append('enable_take_out', enableTakeOut as any);
            }
    
            if (enableOrderQuestions !== undefined) { 
                localVarFormParams.append('enable_order_questions', enableOrderQuestions as any);
            }
    
            if (logo !== undefined) { 
                localVarFormParams.append('logo', logo as any);
            }
    
            if (qrCode !== undefined) { 
                localVarFormParams.append('qr_code', qrCode as any);
            }
    
            if (enableCashPayment !== undefined) { 
                localVarFormParams.append('enable_cash_payment', enableCashPayment as any);
            }
    
            if (enableOnlinePayment !== undefined) { 
                localVarFormParams.append('enable_online_payment', enableOnlinePayment as any);
            }
    
            if (additionalInfo !== undefined) { 
                localVarFormParams.append('additional_info', additionalInfo as any);
            }
    
            if (additionalInfoEn !== undefined) { 
                localVarFormParams.append('additional_info_en', additionalInfoEn as any);
            }
    
            if (genre !== undefined) { 
                localVarFormParams.append('genre', genre as any);
            }
    
            if (genreEn !== undefined) { 
                localVarFormParams.append('genre_en', genreEn as any);
            }
    
            if (bufferTime !== undefined) { 
                localVarFormParams.append('buffer_time', bufferTime as any);
            }
    
            if (nearestStation !== undefined) { 
                localVarFormParams.append('nearest_station', nearestStation as any);
            }
    
            if (nearestStationEn !== undefined) { 
                localVarFormParams.append('nearest_station_en', nearestStationEn as any);
            }
    
            if (customPlatformFeeAmount !== undefined) { 
                localVarFormParams.append('custom_platform_fee_amount', customPlatformFeeAmount as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VenuesApi - functional programming interface
 * @export
 */
export const VenuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VenuesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new venue (admin only). Use multipart/form-data when uploading venue logo or images.
         * @summary Create a new venue
         * @param {string} name 
         * @param {string} address 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesCreate(name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Venue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesCreate(name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a venue (admin only)
         * @summary Delete venue
         * @param {string} id A UUID string identifying this venue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all venues with basic information, ordered by creation date (newest first)
         * @summary List all venues
         * @param {string} [genre] Filter by genre
         * @param {VenuesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {string} [name] Filter by venue name
         * @param {string} [nearestStation] Filter by nearest station
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesList(genre?: string, multilingual?: VenuesListMultilingualEnum, name?: string, nearestStation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Venue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesList(genre, multilingual, name, nearestStation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the complete menu for a venue, including all categories and items
         * @summary Get venue menu
         * @param {string} id A UUID string identifying this venue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenuRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenuRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new menu category for a venue (venue managers or admins only)
         * @summary Create menu category
         * @param {string} venueId 
         * @param {MenuCategoryRequest} menuCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesCreate(venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesCreate(venueId, menuCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a menu category (venue managers or admins only)
         * @summary Delete menu category
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesDestroy(id: string, venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesDestroy(id, venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of menu categories for a venue
         * @summary List menu categories
         * @param {string} venueId 
         * @param {VenuesMenusCategoriesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesList(venueId: string, multilingual?: VenuesMenusCategoriesListMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesList(venueId, multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all menu categories with their associated menu items
         * @summary List categories with items
         * @param {string} venueId 
         * @param {VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesListWithItemsRetrieve(venueId: string, multilingual?: VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuCategoryWithItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesListWithItemsRetrieve(venueId, multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing menu categories
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {PatchedMenuCategoryRequest} [patchedMenuCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesPartialUpdate(id: string, venueId: string, patchedMenuCategoryRequest?: PatchedMenuCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesPartialUpdate(id, venueId, patchedMenuCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about a menu category
         * @summary Get menu category details
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesRetrieve(id: string, venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesRetrieve(id, venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a menu category (venue managers or admins only)
         * @summary Update menu category
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {MenuCategoryRequest} menuCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusCategoriesUpdate(id: string, venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusCategoriesUpdate(id, venueId, menuCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing menu items
         * @param {string} venueId 
         * @param {MenuItemStockUpdateRequest} menuItemStockUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsBulkUpdateStockCreate(venueId: string, menuItemStockUpdateRequest: MenuItemStockUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItemStockUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsBulkUpdateStockCreate(venueId, menuItemStockUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new menu item for a venue (venue managers or admins only). Use multipart/form-data when uploading menu item images.
         * @summary Create menu item
         * @param {string} venueId 
         * @param {string} name 
         * @param {string} price 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsCreate(venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsCreate(venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a menu item (venue managers or admins only)
         * @summary Delete menu item
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsDestroy(id: string, venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsDestroy(id, venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of menu items for a venue
         * @summary List menu items
         * @param {string} venueId 
         * @param {string} [category] Filter by category ID
         * @param {boolean} [isAvailable] Filter by availability
         * @param {VenuesMenusItemsListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsList(venueId: string, category?: string, isAvailable?: boolean, multilingual?: VenuesMenusItemsListMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsList(venueId, category, isAvailable, multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing menu items
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsPartialUpdate(id: string, venueId: string, name?: string, price?: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsPartialUpdate(id, venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about a menu item
         * @summary Get menu item details
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {VenuesMenusItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsRetrieve(id: string, venueId: string, multilingual?: VenuesMenusItemsRetrieveMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsRetrieve(id, venueId, multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a menu item (venue managers or admins only). Use multipart/form-data when uploading menu item images.
         * @summary Update menu item
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {string} name 
         * @param {string} price 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesMenusItemsUpdate(id: string, venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesMenusItemsUpdate(id, venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoints for managing venues
         * @param {string} id A UUID string identifying this venue.
         * @param {string} [name] 
         * @param {string} [address] 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesPartialUpdate(id: string, name?: string, address?: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Venue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesPartialUpdate(id, name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get venue order questions configuration including enable flag and questions list
         * @summary Get venue questions configuration
         * @param {string} venueId 
         * @param {VenuesQuestionsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesQuestionsRetrieve(venueId: string, multilingual?: VenuesQuestionsRetrieveMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenueQuestionsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesQuestionsRetrieve(venueId, multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update venue order questions configuration including enable flag and questions list
         * @summary Update venue questions configuration
         * @param {string} venueId 
         * @param {VenueQuestionsUpdateRequest} [venueQuestionsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesQuestionsUpdate(venueId: string, venueQuestionsUpdateRequest?: VenueQuestionsUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenueQuestionsConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesQuestionsUpdate(venueId, venueQuestionsUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about a venue by ID
         * @summary Get venue details
         * @param {string} id A UUID string identifying this venue.
         * @param {VenuesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesRetrieve(id: string, multilingual?: VenuesRetrieveMultilingualEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenueDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesRetrieve(id, multilingual, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Stripe Connect account for a venue
         * @summary Create Stripe Connect account
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesStripeConnectCreate(venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenuesStripeConnectCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesStripeConnectCreate(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Stripe Connect onboarding link for a venue
         * @summary Create onboarding link
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesStripeConnectOnboardingLinkCreate(venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenuesStripeConnectOnboardingLinkCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesStripeConnectOnboardingLinkCreate(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status of a venue\'s Stripe Connect account
         * @summary Get Stripe Connect account status
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesStripeConnectRetrieve(venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenueStripeConnect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesStripeConnectRetrieve(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a temporary additional limit to a time slot daily limit.
         * @param {string} id 
         * @param {string} venueId 
         * @param {TimeSlotDailyLimitRequest} [timeSlotDailyLimitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsAdditionalLimitCreate(id: string, venueId: string, timeSlotDailyLimitRequest?: TimeSlotDailyLimitRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSlotDailyLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsAdditionalLimitCreate(id, venueId, timeSlotDailyLimitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} venueId 
         * @param {TimeSlotRequest} timeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsCreate(venueId: string, timeSlotRequest: TimeSlotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSlot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsCreate(venueId, timeSlotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsDestroy(id: string, venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsDestroy(id, venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of time slots filtered by service type.
         * @summary List time slots
         * @param {VenuesTimeSlotsListServiceTypeEnum} serviceType Filter by service type (DINE_IN or TAKEOUT)
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsList(serviceType: VenuesTimeSlotsListServiceTypeEnum, venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeSlot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsList(serviceType, venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {PatchedTimeSlotRequest} [patchedTimeSlotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsPartialUpdate(id: string, venueId: string, patchedTimeSlotRequest?: PatchedTimeSlotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSlot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsPartialUpdate(id, venueId, patchedTimeSlotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pause a time slot by setting.
         * @param {string} venueId 
         * @param {PausedTimeSlotRequest} pausedTimeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsPausedTimeSlotsCreate(venueId: string, pausedTimeSlotRequest: PausedTimeSlotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PausedTimeSlot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsPausedTimeSlotsCreate(venueId, pausedTimeSlotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsRetrieve(id: string, venueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSlot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsRetrieve(id, venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {TimeSlotRequest} timeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesTimeSlotsUpdate(id: string, venueId: string, timeSlotRequest: TimeSlotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSlot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesTimeSlotsUpdate(id, venueId, timeSlotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update venue information (venue managers or admins only). Use multipart/form-data when uploading venue logo or images.
         * @summary Update venue
         * @param {string} id A UUID string identifying this venue.
         * @param {string} name 
         * @param {string} address 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async venuesUpdate(id: string, name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Venue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.venuesUpdate(id, name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VenuesApi - factory interface
 * @export
 */
export const VenuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VenuesApiFp(configuration)
    return {
        /**
         * Create a new venue (admin only). Use multipart/form-data when uploading venue logo or images.
         * @summary Create a new venue
         * @param {string} name 
         * @param {string} address 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesCreate(name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: any): AxiosPromise<Venue> {
            return localVarFp.venuesCreate(name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a venue (admin only)
         * @summary Delete venue
         * @param {string} id A UUID string identifying this venue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.venuesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all venues with basic information, ordered by creation date (newest first)
         * @summary List all venues
         * @param {string} [genre] Filter by genre
         * @param {VenuesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {string} [name] Filter by venue name
         * @param {string} [nearestStation] Filter by nearest station
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesList(genre?: string, multilingual?: VenuesListMultilingualEnum, name?: string, nearestStation?: string, options?: any): AxiosPromise<Array<Venue>> {
            return localVarFp.venuesList(genre, multilingual, name, nearestStation, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the complete menu for a venue, including all categories and items
         * @summary Get venue menu
         * @param {string} id A UUID string identifying this venue.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenuRetrieve(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.venuesMenuRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new menu category for a venue (venue managers or admins only)
         * @summary Create menu category
         * @param {string} venueId 
         * @param {MenuCategoryRequest} menuCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesCreate(venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: any): AxiosPromise<MenuCategory> {
            return localVarFp.venuesMenusCategoriesCreate(venueId, menuCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a menu category (venue managers or admins only)
         * @summary Delete menu category
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesDestroy(id: string, venueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.venuesMenusCategoriesDestroy(id, venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of menu categories for a venue
         * @summary List menu categories
         * @param {string} venueId 
         * @param {VenuesMenusCategoriesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesList(venueId: string, multilingual?: VenuesMenusCategoriesListMultilingualEnum, options?: any): AxiosPromise<Array<MenuCategory>> {
            return localVarFp.venuesMenusCategoriesList(venueId, multilingual, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all menu categories with their associated menu items
         * @summary List categories with items
         * @param {string} venueId 
         * @param {VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesListWithItemsRetrieve(venueId: string, multilingual?: VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum, options?: any): AxiosPromise<Array<MenuCategoryWithItems>> {
            return localVarFp.venuesMenusCategoriesListWithItemsRetrieve(venueId, multilingual, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing menu categories
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {PatchedMenuCategoryRequest} [patchedMenuCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesPartialUpdate(id: string, venueId: string, patchedMenuCategoryRequest?: PatchedMenuCategoryRequest, options?: any): AxiosPromise<MenuCategory> {
            return localVarFp.venuesMenusCategoriesPartialUpdate(id, venueId, patchedMenuCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a menu category
         * @summary Get menu category details
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesRetrieve(id: string, venueId: string, options?: any): AxiosPromise<MenuCategory> {
            return localVarFp.venuesMenusCategoriesRetrieve(id, venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a menu category (venue managers or admins only)
         * @summary Update menu category
         * @param {string} id A UUID string identifying this menu category.
         * @param {string} venueId 
         * @param {MenuCategoryRequest} menuCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusCategoriesUpdate(id: string, venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: any): AxiosPromise<MenuCategory> {
            return localVarFp.venuesMenusCategoriesUpdate(id, venueId, menuCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing menu items
         * @param {string} venueId 
         * @param {MenuItemStockUpdateRequest} menuItemStockUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsBulkUpdateStockCreate(venueId: string, menuItemStockUpdateRequest: MenuItemStockUpdateRequest, options?: any): AxiosPromise<MenuItemStockUpdate> {
            return localVarFp.venuesMenusItemsBulkUpdateStockCreate(venueId, menuItemStockUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new menu item for a venue (venue managers or admins only). Use multipart/form-data when uploading menu item images.
         * @summary Create menu item
         * @param {string} venueId 
         * @param {string} name 
         * @param {string} price 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsCreate(venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: any): AxiosPromise<MenuItem> {
            return localVarFp.venuesMenusItemsCreate(venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a menu item (venue managers or admins only)
         * @summary Delete menu item
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsDestroy(id: string, venueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.venuesMenusItemsDestroy(id, venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of menu items for a venue
         * @summary List menu items
         * @param {string} venueId 
         * @param {string} [category] Filter by category ID
         * @param {boolean} [isAvailable] Filter by availability
         * @param {VenuesMenusItemsListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsList(venueId: string, category?: string, isAvailable?: boolean, multilingual?: VenuesMenusItemsListMultilingualEnum, options?: any): AxiosPromise<Array<MenuItem>> {
            return localVarFp.venuesMenusItemsList(venueId, category, isAvailable, multilingual, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing menu items
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsPartialUpdate(id: string, venueId: string, name?: string, price?: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: any): AxiosPromise<MenuItem> {
            return localVarFp.venuesMenusItemsPartialUpdate(id, venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a menu item
         * @summary Get menu item details
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {VenuesMenusItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsRetrieve(id: string, venueId: string, multilingual?: VenuesMenusItemsRetrieveMultilingualEnum, options?: any): AxiosPromise<MenuItemDetail> {
            return localVarFp.venuesMenusItemsRetrieve(id, venueId, multilingual, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a menu item (venue managers or admins only). Use multipart/form-data when uploading menu item images.
         * @summary Update menu item
         * @param {string} id A UUID string identifying this menu item.
         * @param {string} venueId 
         * @param {string} name 
         * @param {string} price 
         * @param {string | null} [description] 
         * @param {File | null} [image] 
         * @param {string | null} [takeOutPrice] 
         * @param {boolean} [isAvailable] 
         * @param {string | null} [category] 
         * @param {string | null} [ingredients] 
         * @param {number | null} [preparationTime] Preparation time in minutes
         * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
         * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesMenusItemsUpdate(id: string, venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: any): AxiosPromise<MenuItem> {
            return localVarFp.venuesMenusItemsUpdate(id, venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoints for managing venues
         * @param {string} id A UUID string identifying this venue.
         * @param {string} [name] 
         * @param {string} [address] 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesPartialUpdate(id: string, name?: string, address?: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: any): AxiosPromise<Venue> {
            return localVarFp.venuesPartialUpdate(id, name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * Get venue order questions configuration including enable flag and questions list
         * @summary Get venue questions configuration
         * @param {string} venueId 
         * @param {VenuesQuestionsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesQuestionsRetrieve(venueId: string, multilingual?: VenuesQuestionsRetrieveMultilingualEnum, options?: any): AxiosPromise<VenueQuestionsConfig> {
            return localVarFp.venuesQuestionsRetrieve(venueId, multilingual, options).then((request) => request(axios, basePath));
        },
        /**
         * Update venue order questions configuration including enable flag and questions list
         * @summary Update venue questions configuration
         * @param {string} venueId 
         * @param {VenueQuestionsUpdateRequest} [venueQuestionsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesQuestionsUpdate(venueId: string, venueQuestionsUpdateRequest?: VenueQuestionsUpdateRequest, options?: any): AxiosPromise<VenueQuestionsConfig> {
            return localVarFp.venuesQuestionsUpdate(venueId, venueQuestionsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a venue by ID
         * @summary Get venue details
         * @param {string} id A UUID string identifying this venue.
         * @param {VenuesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesRetrieve(id: string, multilingual?: VenuesRetrieveMultilingualEnum, options?: any): AxiosPromise<VenueDetail> {
            return localVarFp.venuesRetrieve(id, multilingual, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Stripe Connect account for a venue
         * @summary Create Stripe Connect account
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesStripeConnectCreate(venueId: string, options?: any): AxiosPromise<VenuesStripeConnectCreate200Response> {
            return localVarFp.venuesStripeConnectCreate(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Stripe Connect onboarding link for a venue
         * @summary Create onboarding link
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesStripeConnectOnboardingLinkCreate(venueId: string, options?: any): AxiosPromise<VenuesStripeConnectOnboardingLinkCreate200Response> {
            return localVarFp.venuesStripeConnectOnboardingLinkCreate(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a venue\'s Stripe Connect account
         * @summary Get Stripe Connect account status
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesStripeConnectRetrieve(venueId: string, options?: any): AxiosPromise<VenueStripeConnect> {
            return localVarFp.venuesStripeConnectRetrieve(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a temporary additional limit to a time slot daily limit.
         * @param {string} id 
         * @param {string} venueId 
         * @param {TimeSlotDailyLimitRequest} [timeSlotDailyLimitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsAdditionalLimitCreate(id: string, venueId: string, timeSlotDailyLimitRequest?: TimeSlotDailyLimitRequest, options?: any): AxiosPromise<TimeSlotDailyLimit> {
            return localVarFp.venuesTimeSlotsAdditionalLimitCreate(id, venueId, timeSlotDailyLimitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} venueId 
         * @param {TimeSlotRequest} timeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsCreate(venueId: string, timeSlotRequest: TimeSlotRequest, options?: any): AxiosPromise<TimeSlot> {
            return localVarFp.venuesTimeSlotsCreate(venueId, timeSlotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsDestroy(id: string, venueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.venuesTimeSlotsDestroy(id, venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of time slots filtered by service type.
         * @summary List time slots
         * @param {VenuesTimeSlotsListServiceTypeEnum} serviceType Filter by service type (DINE_IN or TAKEOUT)
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsList(serviceType: VenuesTimeSlotsListServiceTypeEnum, venueId: string, options?: any): AxiosPromise<Array<TimeSlot>> {
            return localVarFp.venuesTimeSlotsList(serviceType, venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {PatchedTimeSlotRequest} [patchedTimeSlotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsPartialUpdate(id: string, venueId: string, patchedTimeSlotRequest?: PatchedTimeSlotRequest, options?: any): AxiosPromise<TimeSlot> {
            return localVarFp.venuesTimeSlotsPartialUpdate(id, venueId, patchedTimeSlotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Pause a time slot by setting.
         * @param {string} venueId 
         * @param {PausedTimeSlotRequest} pausedTimeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsPausedTimeSlotsCreate(venueId: string, pausedTimeSlotRequest: PausedTimeSlotRequest, options?: any): AxiosPromise<PausedTimeSlot> {
            return localVarFp.venuesTimeSlotsPausedTimeSlotsCreate(venueId, pausedTimeSlotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsRetrieve(id: string, venueId: string, options?: any): AxiosPromise<TimeSlot> {
            return localVarFp.venuesTimeSlotsRetrieve(id, venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} venueId 
         * @param {TimeSlotRequest} timeSlotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesTimeSlotsUpdate(id: string, venueId: string, timeSlotRequest: TimeSlotRequest, options?: any): AxiosPromise<TimeSlot> {
            return localVarFp.venuesTimeSlotsUpdate(id, venueId, timeSlotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update venue information (venue managers or admins only). Use multipart/form-data when uploading venue logo or images.
         * @summary Update venue
         * @param {string} id A UUID string identifying this venue.
         * @param {string} name 
         * @param {string} address 
         * @param {string} [description] 
         * @param {string} [announcement] 
         * @param {string} [phoneNumber] 
         * @param {string | null} [email] 
         * @param {string | null} [website] 
         * @param {string | null} [openingTime] 
         * @param {string | null} [closingTime] 
         * @param {boolean} [isActive] 
         * @param {boolean} [enableReservation] 
         * @param {boolean} [enableEatIn] 
         * @param {boolean} [enableTakeOut] 
         * @param {boolean} [enableOrderQuestions] 
         * @param {File | null} [logo] 
         * @param {string | null} [qrCode] 
         * @param {boolean} [enableCashPayment] 
         * @param {boolean} [enableOnlinePayment] 
         * @param {string | null} [additionalInfo] 
         * @param {string} [additionalInfoEn] 
         * @param {string | null} [genre] 
         * @param {string} [genreEn] 
         * @param {number} [bufferTime] 
         * @param {string | null} [nearestStation] 
         * @param {string} [nearestStationEn] 
         * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        venuesUpdate(id: string, name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: any): AxiosPromise<Venue> {
            return localVarFp.venuesUpdate(id, name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VenuesApi - interface
 * @export
 * @interface VenuesApi
 */
export interface VenuesApiInterface {
    /**
     * Create a new venue (admin only). Use multipart/form-data when uploading venue logo or images.
     * @summary Create a new venue
     * @param {string} name 
     * @param {string} address 
     * @param {string} [description] 
     * @param {string} [announcement] 
     * @param {string} [phoneNumber] 
     * @param {string | null} [email] 
     * @param {string | null} [website] 
     * @param {string | null} [openingTime] 
     * @param {string | null} [closingTime] 
     * @param {boolean} [isActive] 
     * @param {boolean} [enableReservation] 
     * @param {boolean} [enableEatIn] 
     * @param {boolean} [enableTakeOut] 
     * @param {boolean} [enableOrderQuestions] 
     * @param {File | null} [logo] 
     * @param {string | null} [qrCode] 
     * @param {boolean} [enableCashPayment] 
     * @param {boolean} [enableOnlinePayment] 
     * @param {string | null} [additionalInfo] 
     * @param {string} [additionalInfoEn] 
     * @param {string | null} [genre] 
     * @param {string} [genreEn] 
     * @param {number} [bufferTime] 
     * @param {string | null} [nearestStation] 
     * @param {string} [nearestStationEn] 
     * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesCreate(name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig): AxiosPromise<Venue>;

    /**
     * Delete a venue (admin only)
     * @summary Delete venue
     * @param {string} id A UUID string identifying this venue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesDestroy(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of all venues with basic information, ordered by creation date (newest first)
     * @summary List all venues
     * @param {string} [genre] Filter by genre
     * @param {VenuesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {string} [name] Filter by venue name
     * @param {string} [nearestStation] Filter by nearest station
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesList(genre?: string, multilingual?: VenuesListMultilingualEnum, name?: string, nearestStation?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Venue>>;

    /**
     * Get the complete menu for a venue, including all categories and items
     * @summary Get venue menu
     * @param {string} id A UUID string identifying this venue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenuRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Create a new menu category for a venue (venue managers or admins only)
     * @summary Create menu category
     * @param {string} venueId 
     * @param {MenuCategoryRequest} menuCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesCreate(venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<MenuCategory>;

    /**
     * Delete a menu category (venue managers or admins only)
     * @summary Delete menu category
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesDestroy(id: string, venueId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of menu categories for a venue
     * @summary List menu categories
     * @param {string} venueId 
     * @param {VenuesMenusCategoriesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesList(venueId: string, multilingual?: VenuesMenusCategoriesListMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<Array<MenuCategory>>;

    /**
     * Get all menu categories with their associated menu items
     * @summary List categories with items
     * @param {string} venueId 
     * @param {VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesListWithItemsRetrieve(venueId: string, multilingual?: VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<Array<MenuCategoryWithItems>>;

    /**
     * API endpoints for managing menu categories
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {PatchedMenuCategoryRequest} [patchedMenuCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesPartialUpdate(id: string, venueId: string, patchedMenuCategoryRequest?: PatchedMenuCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<MenuCategory>;

    /**
     * Get detailed information about a menu category
     * @summary Get menu category details
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesRetrieve(id: string, venueId: string, options?: AxiosRequestConfig): AxiosPromise<MenuCategory>;

    /**
     * Update a menu category (venue managers or admins only)
     * @summary Update menu category
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {MenuCategoryRequest} menuCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusCategoriesUpdate(id: string, venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: AxiosRequestConfig): AxiosPromise<MenuCategory>;

    /**
     * API endpoints for managing menu items
     * @param {string} venueId 
     * @param {MenuItemStockUpdateRequest} menuItemStockUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsBulkUpdateStockCreate(venueId: string, menuItemStockUpdateRequest: MenuItemStockUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<MenuItemStockUpdate>;

    /**
     * Create a new menu item for a venue (venue managers or admins only). Use multipart/form-data when uploading menu item images.
     * @summary Create menu item
     * @param {string} venueId 
     * @param {string} name 
     * @param {string} price 
     * @param {string | null} [description] 
     * @param {File | null} [image] 
     * @param {string | null} [takeOutPrice] 
     * @param {boolean} [isAvailable] 
     * @param {string | null} [category] 
     * @param {string | null} [ingredients] 
     * @param {number | null} [preparationTime] Preparation time in minutes
     * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
     * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsCreate(venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig): AxiosPromise<MenuItem>;

    /**
     * Delete a menu item (venue managers or admins only)
     * @summary Delete menu item
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsDestroy(id: string, venueId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a list of menu items for a venue
     * @summary List menu items
     * @param {string} venueId 
     * @param {string} [category] Filter by category ID
     * @param {boolean} [isAvailable] Filter by availability
     * @param {VenuesMenusItemsListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsList(venueId: string, category?: string, isAvailable?: boolean, multilingual?: VenuesMenusItemsListMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<Array<MenuItem>>;

    /**
     * API endpoints for managing menu items
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {string} [name] 
     * @param {string} [price] 
     * @param {string | null} [description] 
     * @param {File | null} [image] 
     * @param {string | null} [takeOutPrice] 
     * @param {boolean} [isAvailable] 
     * @param {string | null} [category] 
     * @param {string | null} [ingredients] 
     * @param {number | null} [preparationTime] Preparation time in minutes
     * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
     * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsPartialUpdate(id: string, venueId: string, name?: string, price?: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig): AxiosPromise<MenuItem>;

    /**
     * Get detailed information about a menu item
     * @summary Get menu item details
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {VenuesMenusItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsRetrieve(id: string, venueId: string, multilingual?: VenuesMenusItemsRetrieveMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<MenuItemDetail>;

    /**
     * Update a menu item (venue managers or admins only). Use multipart/form-data when uploading menu item images.
     * @summary Update menu item
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {string} name 
     * @param {string} price 
     * @param {string | null} [description] 
     * @param {File | null} [image] 
     * @param {string | null} [takeOutPrice] 
     * @param {boolean} [isAvailable] 
     * @param {string | null} [category] 
     * @param {string | null} [ingredients] 
     * @param {number | null} [preparationTime] Preparation time in minutes
     * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
     * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesMenusItemsUpdate(id: string, venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig): AxiosPromise<MenuItem>;

    /**
     * API endpoints for managing venues
     * @param {string} id A UUID string identifying this venue.
     * @param {string} [name] 
     * @param {string} [address] 
     * @param {string} [description] 
     * @param {string} [announcement] 
     * @param {string} [phoneNumber] 
     * @param {string | null} [email] 
     * @param {string | null} [website] 
     * @param {string | null} [openingTime] 
     * @param {string | null} [closingTime] 
     * @param {boolean} [isActive] 
     * @param {boolean} [enableReservation] 
     * @param {boolean} [enableEatIn] 
     * @param {boolean} [enableTakeOut] 
     * @param {boolean} [enableOrderQuestions] 
     * @param {File | null} [logo] 
     * @param {string | null} [qrCode] 
     * @param {boolean} [enableCashPayment] 
     * @param {boolean} [enableOnlinePayment] 
     * @param {string | null} [additionalInfo] 
     * @param {string} [additionalInfoEn] 
     * @param {string | null} [genre] 
     * @param {string} [genreEn] 
     * @param {number} [bufferTime] 
     * @param {string | null} [nearestStation] 
     * @param {string} [nearestStationEn] 
     * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesPartialUpdate(id: string, name?: string, address?: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig): AxiosPromise<Venue>;

    /**
     * Get venue order questions configuration including enable flag and questions list
     * @summary Get venue questions configuration
     * @param {string} venueId 
     * @param {VenuesQuestionsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesQuestionsRetrieve(venueId: string, multilingual?: VenuesQuestionsRetrieveMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<VenueQuestionsConfig>;

    /**
     * Update venue order questions configuration including enable flag and questions list
     * @summary Update venue questions configuration
     * @param {string} venueId 
     * @param {VenueQuestionsUpdateRequest} [venueQuestionsUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesQuestionsUpdate(venueId: string, venueQuestionsUpdateRequest?: VenueQuestionsUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<VenueQuestionsConfig>;

    /**
     * Get detailed information about a venue by ID
     * @summary Get venue details
     * @param {string} id A UUID string identifying this venue.
     * @param {VenuesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesRetrieve(id: string, multilingual?: VenuesRetrieveMultilingualEnum, options?: AxiosRequestConfig): AxiosPromise<VenueDetail>;

    /**
     * Create a new Stripe Connect account for a venue
     * @summary Create Stripe Connect account
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesStripeConnectCreate(venueId: string, options?: AxiosRequestConfig): AxiosPromise<VenuesStripeConnectCreate200Response>;

    /**
     * Create a Stripe Connect onboarding link for a venue
     * @summary Create onboarding link
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesStripeConnectOnboardingLinkCreate(venueId: string, options?: AxiosRequestConfig): AxiosPromise<VenuesStripeConnectOnboardingLinkCreate200Response>;

    /**
     * Get the status of a venue\'s Stripe Connect account
     * @summary Get Stripe Connect account status
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesStripeConnectRetrieve(venueId: string, options?: AxiosRequestConfig): AxiosPromise<VenueStripeConnect>;

    /**
     * Add a temporary additional limit to a time slot daily limit.
     * @param {string} id 
     * @param {string} venueId 
     * @param {TimeSlotDailyLimitRequest} [timeSlotDailyLimitRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsAdditionalLimitCreate(id: string, venueId: string, timeSlotDailyLimitRequest?: TimeSlotDailyLimitRequest, options?: AxiosRequestConfig): AxiosPromise<TimeSlotDailyLimit>;

    /**
     * 
     * @param {string} venueId 
     * @param {TimeSlotRequest} timeSlotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsCreate(venueId: string, timeSlotRequest: TimeSlotRequest, options?: AxiosRequestConfig): AxiosPromise<TimeSlot>;

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsDestroy(id: string, venueId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a list of time slots filtered by service type.
     * @summary List time slots
     * @param {VenuesTimeSlotsListServiceTypeEnum} serviceType Filter by service type (DINE_IN or TAKEOUT)
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsList(serviceType: VenuesTimeSlotsListServiceTypeEnum, venueId: string, options?: AxiosRequestConfig): AxiosPromise<Array<TimeSlot>>;

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {PatchedTimeSlotRequest} [patchedTimeSlotRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsPartialUpdate(id: string, venueId: string, patchedTimeSlotRequest?: PatchedTimeSlotRequest, options?: AxiosRequestConfig): AxiosPromise<TimeSlot>;

    /**
     * Pause a time slot by setting.
     * @param {string} venueId 
     * @param {PausedTimeSlotRequest} pausedTimeSlotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsPausedTimeSlotsCreate(venueId: string, pausedTimeSlotRequest: PausedTimeSlotRequest, options?: AxiosRequestConfig): AxiosPromise<PausedTimeSlot>;

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsRetrieve(id: string, venueId: string, options?: AxiosRequestConfig): AxiosPromise<TimeSlot>;

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {TimeSlotRequest} timeSlotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesTimeSlotsUpdate(id: string, venueId: string, timeSlotRequest: TimeSlotRequest, options?: AxiosRequestConfig): AxiosPromise<TimeSlot>;

    /**
     * Update venue information (venue managers or admins only). Use multipart/form-data when uploading venue logo or images.
     * @summary Update venue
     * @param {string} id A UUID string identifying this venue.
     * @param {string} name 
     * @param {string} address 
     * @param {string} [description] 
     * @param {string} [announcement] 
     * @param {string} [phoneNumber] 
     * @param {string | null} [email] 
     * @param {string | null} [website] 
     * @param {string | null} [openingTime] 
     * @param {string | null} [closingTime] 
     * @param {boolean} [isActive] 
     * @param {boolean} [enableReservation] 
     * @param {boolean} [enableEatIn] 
     * @param {boolean} [enableTakeOut] 
     * @param {boolean} [enableOrderQuestions] 
     * @param {File | null} [logo] 
     * @param {string | null} [qrCode] 
     * @param {boolean} [enableCashPayment] 
     * @param {boolean} [enableOnlinePayment] 
     * @param {string | null} [additionalInfo] 
     * @param {string} [additionalInfoEn] 
     * @param {string | null} [genre] 
     * @param {string} [genreEn] 
     * @param {number} [bufferTime] 
     * @param {string | null} [nearestStation] 
     * @param {string} [nearestStationEn] 
     * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApiInterface
     */
    venuesUpdate(id: string, name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig): AxiosPromise<Venue>;

}

/**
 * VenuesApi - object-oriented interface
 * @export
 * @class VenuesApi
 * @extends {BaseAPI}
 */
export class VenuesApi extends BaseAPI implements VenuesApiInterface {
    /**
     * Create a new venue (admin only). Use multipart/form-data when uploading venue logo or images.
     * @summary Create a new venue
     * @param {string} name 
     * @param {string} address 
     * @param {string} [description] 
     * @param {string} [announcement] 
     * @param {string} [phoneNumber] 
     * @param {string | null} [email] 
     * @param {string | null} [website] 
     * @param {string | null} [openingTime] 
     * @param {string | null} [closingTime] 
     * @param {boolean} [isActive] 
     * @param {boolean} [enableReservation] 
     * @param {boolean} [enableEatIn] 
     * @param {boolean} [enableTakeOut] 
     * @param {boolean} [enableOrderQuestions] 
     * @param {File | null} [logo] 
     * @param {string | null} [qrCode] 
     * @param {boolean} [enableCashPayment] 
     * @param {boolean} [enableOnlinePayment] 
     * @param {string | null} [additionalInfo] 
     * @param {string} [additionalInfoEn] 
     * @param {string | null} [genre] 
     * @param {string} [genreEn] 
     * @param {number} [bufferTime] 
     * @param {string | null} [nearestStation] 
     * @param {string} [nearestStationEn] 
     * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesCreate(name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesCreate(name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a venue (admin only)
     * @summary Delete venue
     * @param {string} id A UUID string identifying this venue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesDestroy(id: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all venues with basic information, ordered by creation date (newest first)
     * @summary List all venues
     * @param {string} [genre] Filter by genre
     * @param {VenuesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {string} [name] Filter by venue name
     * @param {string} [nearestStation] Filter by nearest station
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesList(genre?: string, multilingual?: VenuesListMultilingualEnum, name?: string, nearestStation?: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesList(genre, multilingual, name, nearestStation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the complete menu for a venue, including all categories and items
     * @summary Get venue menu
     * @param {string} id A UUID string identifying this venue.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenuRetrieve(id: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenuRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new menu category for a venue (venue managers or admins only)
     * @summary Create menu category
     * @param {string} venueId 
     * @param {MenuCategoryRequest} menuCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesCreate(venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesCreate(venueId, menuCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a menu category (venue managers or admins only)
     * @summary Delete menu category
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesDestroy(id: string, venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesDestroy(id, venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of menu categories for a venue
     * @summary List menu categories
     * @param {string} venueId 
     * @param {VenuesMenusCategoriesListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesList(venueId: string, multilingual?: VenuesMenusCategoriesListMultilingualEnum, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesList(venueId, multilingual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all menu categories with their associated menu items
     * @summary List categories with items
     * @param {string} venueId 
     * @param {VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesListWithItemsRetrieve(venueId: string, multilingual?: VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesListWithItemsRetrieve(venueId, multilingual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing menu categories
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {PatchedMenuCategoryRequest} [patchedMenuCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesPartialUpdate(id: string, venueId: string, patchedMenuCategoryRequest?: PatchedMenuCategoryRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesPartialUpdate(id, venueId, patchedMenuCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a menu category
     * @summary Get menu category details
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesRetrieve(id: string, venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesRetrieve(id, venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a menu category (venue managers or admins only)
     * @summary Update menu category
     * @param {string} id A UUID string identifying this menu category.
     * @param {string} venueId 
     * @param {MenuCategoryRequest} menuCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusCategoriesUpdate(id: string, venueId: string, menuCategoryRequest: MenuCategoryRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusCategoriesUpdate(id, venueId, menuCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing menu items
     * @param {string} venueId 
     * @param {MenuItemStockUpdateRequest} menuItemStockUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsBulkUpdateStockCreate(venueId: string, menuItemStockUpdateRequest: MenuItemStockUpdateRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsBulkUpdateStockCreate(venueId, menuItemStockUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new menu item for a venue (venue managers or admins only). Use multipart/form-data when uploading menu item images.
     * @summary Create menu item
     * @param {string} venueId 
     * @param {string} name 
     * @param {string} price 
     * @param {string | null} [description] 
     * @param {File | null} [image] 
     * @param {string | null} [takeOutPrice] 
     * @param {boolean} [isAvailable] 
     * @param {string | null} [category] 
     * @param {string | null} [ingredients] 
     * @param {number | null} [preparationTime] Preparation time in minutes
     * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
     * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsCreate(venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsCreate(venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a menu item (venue managers or admins only)
     * @summary Delete menu item
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsDestroy(id: string, venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsDestroy(id, venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of menu items for a venue
     * @summary List menu items
     * @param {string} venueId 
     * @param {string} [category] Filter by category ID
     * @param {boolean} [isAvailable] Filter by availability
     * @param {VenuesMenusItemsListMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsList(venueId: string, category?: string, isAvailable?: boolean, multilingual?: VenuesMenusItemsListMultilingualEnum, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsList(venueId, category, isAvailable, multilingual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing menu items
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {string} [name] 
     * @param {string} [price] 
     * @param {string | null} [description] 
     * @param {File | null} [image] 
     * @param {string | null} [takeOutPrice] 
     * @param {boolean} [isAvailable] 
     * @param {string | null} [category] 
     * @param {string | null} [ingredients] 
     * @param {number | null} [preparationTime] Preparation time in minutes
     * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
     * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsPartialUpdate(id: string, venueId: string, name?: string, price?: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsPartialUpdate(id, venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a menu item
     * @summary Get menu item details
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {VenuesMenusItemsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsRetrieve(id: string, venueId: string, multilingual?: VenuesMenusItemsRetrieveMultilingualEnum, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsRetrieve(id, venueId, multilingual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a menu item (venue managers or admins only). Use multipart/form-data when uploading menu item images.
     * @summary Update menu item
     * @param {string} id A UUID string identifying this menu item.
     * @param {string} venueId 
     * @param {string} name 
     * @param {string} price 
     * @param {string | null} [description] 
     * @param {File | null} [image] 
     * @param {string | null} [takeOutPrice] 
     * @param {boolean} [isAvailable] 
     * @param {string | null} [category] 
     * @param {string | null} [ingredients] 
     * @param {number | null} [preparationTime] Preparation time in minutes
     * @param {boolean} [isAlcoholic] Does this menu item contain alcohol?
     * @param {boolean} [isPriorityPass] Is this menu item a priority pass?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesMenusItemsUpdate(id: string, venueId: string, name: string, price: string, description?: string | null, image?: File | null, takeOutPrice?: string | null, isAvailable?: boolean, category?: string | null, ingredients?: string | null, preparationTime?: number | null, isAlcoholic?: boolean, isPriorityPass?: boolean, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesMenusItemsUpdate(id, venueId, name, price, description, image, takeOutPrice, isAvailable, category, ingredients, preparationTime, isAlcoholic, isPriorityPass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoints for managing venues
     * @param {string} id A UUID string identifying this venue.
     * @param {string} [name] 
     * @param {string} [address] 
     * @param {string} [description] 
     * @param {string} [announcement] 
     * @param {string} [phoneNumber] 
     * @param {string | null} [email] 
     * @param {string | null} [website] 
     * @param {string | null} [openingTime] 
     * @param {string | null} [closingTime] 
     * @param {boolean} [isActive] 
     * @param {boolean} [enableReservation] 
     * @param {boolean} [enableEatIn] 
     * @param {boolean} [enableTakeOut] 
     * @param {boolean} [enableOrderQuestions] 
     * @param {File | null} [logo] 
     * @param {string | null} [qrCode] 
     * @param {boolean} [enableCashPayment] 
     * @param {boolean} [enableOnlinePayment] 
     * @param {string | null} [additionalInfo] 
     * @param {string} [additionalInfoEn] 
     * @param {string | null} [genre] 
     * @param {string} [genreEn] 
     * @param {number} [bufferTime] 
     * @param {string | null} [nearestStation] 
     * @param {string} [nearestStationEn] 
     * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesPartialUpdate(id: string, name?: string, address?: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesPartialUpdate(id, name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get venue order questions configuration including enable flag and questions list
     * @summary Get venue questions configuration
     * @param {string} venueId 
     * @param {VenuesQuestionsRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesQuestionsRetrieve(venueId: string, multilingual?: VenuesQuestionsRetrieveMultilingualEnum, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesQuestionsRetrieve(venueId, multilingual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update venue order questions configuration including enable flag and questions list
     * @summary Update venue questions configuration
     * @param {string} venueId 
     * @param {VenueQuestionsUpdateRequest} [venueQuestionsUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesQuestionsUpdate(venueId: string, venueQuestionsUpdateRequest?: VenueQuestionsUpdateRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesQuestionsUpdate(venueId, venueQuestionsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a venue by ID
     * @summary Get venue details
     * @param {string} id A UUID string identifying this venue.
     * @param {VenuesRetrieveMultilingualEnum} [multilingual] Enable multilingual translation based on Accept-Language header. Set to \&quot;false\&quot; to disable and return original data (default: \&quot;true\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesRetrieve(id: string, multilingual?: VenuesRetrieveMultilingualEnum, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesRetrieve(id, multilingual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Stripe Connect account for a venue
     * @summary Create Stripe Connect account
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesStripeConnectCreate(venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesStripeConnectCreate(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Stripe Connect onboarding link for a venue
     * @summary Create onboarding link
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesStripeConnectOnboardingLinkCreate(venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesStripeConnectOnboardingLinkCreate(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a venue\'s Stripe Connect account
     * @summary Get Stripe Connect account status
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesStripeConnectRetrieve(venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesStripeConnectRetrieve(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a temporary additional limit to a time slot daily limit.
     * @param {string} id 
     * @param {string} venueId 
     * @param {TimeSlotDailyLimitRequest} [timeSlotDailyLimitRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsAdditionalLimitCreate(id: string, venueId: string, timeSlotDailyLimitRequest?: TimeSlotDailyLimitRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsAdditionalLimitCreate(id, venueId, timeSlotDailyLimitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} venueId 
     * @param {TimeSlotRequest} timeSlotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsCreate(venueId: string, timeSlotRequest: TimeSlotRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsCreate(venueId, timeSlotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsDestroy(id: string, venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsDestroy(id, venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of time slots filtered by service type.
     * @summary List time slots
     * @param {VenuesTimeSlotsListServiceTypeEnum} serviceType Filter by service type (DINE_IN or TAKEOUT)
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsList(serviceType: VenuesTimeSlotsListServiceTypeEnum, venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsList(serviceType, venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {PatchedTimeSlotRequest} [patchedTimeSlotRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsPartialUpdate(id: string, venueId: string, patchedTimeSlotRequest?: PatchedTimeSlotRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsPartialUpdate(id, venueId, patchedTimeSlotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pause a time slot by setting.
     * @param {string} venueId 
     * @param {PausedTimeSlotRequest} pausedTimeSlotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsPausedTimeSlotsCreate(venueId: string, pausedTimeSlotRequest: PausedTimeSlotRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsPausedTimeSlotsCreate(venueId, pausedTimeSlotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsRetrieve(id: string, venueId: string, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsRetrieve(id, venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} venueId 
     * @param {TimeSlotRequest} timeSlotRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesTimeSlotsUpdate(id: string, venueId: string, timeSlotRequest: TimeSlotRequest, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesTimeSlotsUpdate(id, venueId, timeSlotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update venue information (venue managers or admins only). Use multipart/form-data when uploading venue logo or images.
     * @summary Update venue
     * @param {string} id A UUID string identifying this venue.
     * @param {string} name 
     * @param {string} address 
     * @param {string} [description] 
     * @param {string} [announcement] 
     * @param {string} [phoneNumber] 
     * @param {string | null} [email] 
     * @param {string | null} [website] 
     * @param {string | null} [openingTime] 
     * @param {string | null} [closingTime] 
     * @param {boolean} [isActive] 
     * @param {boolean} [enableReservation] 
     * @param {boolean} [enableEatIn] 
     * @param {boolean} [enableTakeOut] 
     * @param {boolean} [enableOrderQuestions] 
     * @param {File | null} [logo] 
     * @param {string | null} [qrCode] 
     * @param {boolean} [enableCashPayment] 
     * @param {boolean} [enableOnlinePayment] 
     * @param {string | null} [additionalInfo] 
     * @param {string} [additionalInfoEn] 
     * @param {string | null} [genre] 
     * @param {string} [genreEn] 
     * @param {number} [bufferTime] 
     * @param {string | null} [nearestStation] 
     * @param {string} [nearestStationEn] 
     * @param {number | null} [customPlatformFeeAmount] Absolute application fee amount in JPY for takeout orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public venuesUpdate(id: string, name: string, address: string, description?: string, announcement?: string, phoneNumber?: string, email?: string | null, website?: string | null, openingTime?: string | null, closingTime?: string | null, isActive?: boolean, enableReservation?: boolean, enableEatIn?: boolean, enableTakeOut?: boolean, enableOrderQuestions?: boolean, logo?: File | null, qrCode?: string | null, enableCashPayment?: boolean, enableOnlinePayment?: boolean, additionalInfo?: string | null, additionalInfoEn?: string, genre?: string | null, genreEn?: string, bufferTime?: number, nearestStation?: string | null, nearestStationEn?: string, customPlatformFeeAmount?: number | null, options?: AxiosRequestConfig) {
        return VenuesApiFp(this.configuration).venuesUpdate(id, name, address, description, announcement, phoneNumber, email, website, openingTime, closingTime, isActive, enableReservation, enableEatIn, enableTakeOut, enableOrderQuestions, logo, qrCode, enableCashPayment, enableOnlinePayment, additionalInfo, additionalInfoEn, genre, genreEn, bufferTime, nearestStation, nearestStationEn, customPlatformFeeAmount, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const VenuesListMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesListMultilingualEnum = typeof VenuesListMultilingualEnum[keyof typeof VenuesListMultilingualEnum];
/**
 * @export
 */
export const VenuesMenusCategoriesListMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesMenusCategoriesListMultilingualEnum = typeof VenuesMenusCategoriesListMultilingualEnum[keyof typeof VenuesMenusCategoriesListMultilingualEnum];
/**
 * @export
 */
export const VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum = typeof VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum[keyof typeof VenuesMenusCategoriesListWithItemsRetrieveMultilingualEnum];
/**
 * @export
 */
export const VenuesMenusItemsListMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesMenusItemsListMultilingualEnum = typeof VenuesMenusItemsListMultilingualEnum[keyof typeof VenuesMenusItemsListMultilingualEnum];
/**
 * @export
 */
export const VenuesMenusItemsRetrieveMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesMenusItemsRetrieveMultilingualEnum = typeof VenuesMenusItemsRetrieveMultilingualEnum[keyof typeof VenuesMenusItemsRetrieveMultilingualEnum];
/**
 * @export
 */
export const VenuesQuestionsRetrieveMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesQuestionsRetrieveMultilingualEnum = typeof VenuesQuestionsRetrieveMultilingualEnum[keyof typeof VenuesQuestionsRetrieveMultilingualEnum];
/**
 * @export
 */
export const VenuesRetrieveMultilingualEnum = {
    False: 'false',
    True: 'true'
} as const;
export type VenuesRetrieveMultilingualEnum = typeof VenuesRetrieveMultilingualEnum[keyof typeof VenuesRetrieveMultilingualEnum];
/**
 * @export
 */
export const VenuesTimeSlotsListServiceTypeEnum = {
    DineIn: 'DINE_IN',
    Takeout: 'TAKEOUT'
} as const;
export type VenuesTimeSlotsListServiceTypeEnum = typeof VenuesTimeSlotsListServiceTypeEnum[keyof typeof VenuesTimeSlotsListServiceTypeEnum];


